
#ifndef INSTRUCTION_GUARD
#define INSTRUCTION_GUARD

#include "writer.h"
#include "graph_factor.h"
#include "datatypes.h"
#include "tagmaster.h"
#include "taghandler.h"

#include <map>
#include <vector>

namespace ctb
{
  /**
   * Where to search
   * ---------------
   * Note that this doc is a bit deprecated. For up-to-date information please see relevant files:
   * - loader_xml.h - for formal description of fields
   * - aliasenv_generator.h - for up-to-date aliases which are available *inside* the generation environment (i.e. $name like abbreviations which may be used inside of code/code1/code2/code_custom fields.
   * - writer.h - for full syntax supported by preprocessor
   * - ctb.h on how instruction table is supposed to be loaded and used
   *
   * General description
   * -------------------
   * This class holds information for conversion of instructions from graph op codes to actual code.
   *
   * The logical structure is the following:
   * \code{txt}
   * - instruction table
   *   - operations
   *     operation represents a logical operation such as addition
   *     - instructions
   *       instruction structure represents realization of its parent operation on data of some length
   *     e.g. '$arg1 + $arg2'
   *   - types
   *     type represents again a logical type sucha as an integer
   *     - type versions
   *       specifies data type of a particular width, such as 'int' or '__m128i'
   *     - type conversion
   *       provides a means of splitting or gluing two registers together
   *       one of 3 code types may be specified:
   *       + two code lines are provided for split of an instruction into two halves; semantics of this is {'$type $name = $code1;', '$type $name = $code2'}(names are different in each call) (generated ntimes (with different names and vindexes)
   *         e.g. _mm_unpacklo_epi32($arg1,$arg2)
   *       + code custom - here you get full list of names and it's your problem to cope with them; semantics is '$code_custom' (-||-)
   *       + code generic - this is called once for every instance of split or join with a vector indices as a parameters; semantics is thus {'$code_generic'(with vvindex = 0*w), '$code_generic' (with vvindex = 1*w), '$code_generic'...} (-||-)
   *
   * \endcode
   * 
   * All relevant structures have also a 'note', 'tags' and 'rating' fields. Tags serve for switching hardware-supported/unsupported sets of instructions on and off. Rating serves for choosing better variant when multiple are available (such as a new, mostly unsupported instruction versus an old slow workaround). Note is an arbitrary user note.
   *
   * All 'code' fields are supposed to be in form of rhs expressions, which are later substitued into abbreviations specified by the aliasenv_generator class (or its descendants). For special purposes there may later be a 'code_custom' field introduced, which will allow specification of the full code on user side. All code fields have a shell like expansion format defined by the writer class with abbreviations provided by the aliasenv_maker.hierarchy. At the time of writting this, the following abbreviations are available in code generation:
   *  - $type      - e.g. 'int'
   *  - $name      - name generated for the variable
   *  - $basename  - name of the first variable in vector - e.g. for the purpose of generating one unique variable for every pipe (e.g. for preloads)
   *  - $operation - operation::instruction::code
   *  - $cindex    - for input or output node this is the serial number of this node (e.g. id of the input list which is associated with the instruction in question)
   *  - $arg1      - access code obtained 'from the input edges'...
   *  - $arg2
   *  - $arg3
   *  - $arg...
   *  - $iindex    - input 'vector' index - index of the generated code. E.g. for standard instruction of width = 4 and data granularity 16 the generator will be called in order with this set to 0, 4, 8 and 12;
   *  - $oindex    - output 'vector' index - differs for split and join operations
   *  - $vindex    - 'vector vector' index - internal index for generic joins and splits. E.g. for split from width 8 to 4*2 at granularity 16 this will be called in two series with 0,2,4,8,0,2,4,8 (and iindexes 0,0,0,0,8,8,8,8). This should always be the difference of iindex and oindex
   *
   *  The flag field specifies special semantics for some operations:
   *  - input - allows aliasenv direct access to input nodes, has special semantics for managed 'code' field (i.e. is expanded through '$inputcode' instead of '$innercode')
   *  - output - -||-
   *  - debug - Operations with 'debug' flag set serve for debug. They may be easily used for getting values from a specific part of graph for a specified frame. Debug operation has semantics similar to the output flag except for a few details - these node may be autogenerated using testloader for all or for specified nodes. Width is set to width of the debugged node - i.e. there is no width conversion.
   *
   *  The input interface consists of the instruction_table::addtype and the instruction_table::add_operation create new operation/type with specified id and return a reference to it, which then can be used to fill in code snippets for realization of the code/snippets.
   *
   *  The output interface consists of two 'decode' methods, which return either type of operation. The data retrieval interface is the interface of the operation class, which provides retrieval of all codes, including the type-related stuff.
   *
   *  Instruction selection
   *  ---------------------
   *  Selection of instructions is driven by a serie of tag handlers* organized into layers. Curently there are two layers:
   *  - 'select' layer - defines whether an instruction version can be selected in the run
   *  - 'print' layer - defines whether code for an instruction should be printed or not
   *  These allow higher level layer of a program to generate only a part of a graph depending on tags of instructions. 
   *
   *  Every layer can contain an arbitrary tag handlers. These are intersected separately for each layer and the result is cached into the instruction version data structure. (this happens in the update_tags() call). 
   *
   *  *(Tag handler is basically a functor which receives a stringlist of masks and decides whether those masks satisfy some (user-defined) conditions)
   *
   *  template arguments
   *  ------------------
   *  T - traits
   * */

  template <class T>
    class instruction_table //provides transition from opcode to abstract operation
    {
      private:
        class type;
        class operation;
        template <typename A> using proxy = proxy_<A,instruction_table,operation,type>;
        //holds hardware type info (if needed, theoreticaly is instruction specific and thus may not be neccessary)
        //holds information for changing breadth of data
        class type
        {
          private:
            friend instruction_table;
            struct conversion
            {
              const int width_in;
              const int width_out;
              const std::string code1;
              const std::string code2;
              const std::string code_custom;
              const std::string code_generic;
              const std::string note;
              const std::string tags;
              const int rating;
              mutable typename T::flag_t satisfactory;
              conversion(int in, int out, const std::string& c1, const std::string& c2,const std::string&,const std::string&,const std::string&, const std::string&, int r, bool s);
              conversion() = delete;
            } ;
            struct type_version
            {
              const int width;
              const std::string code;
              const std::string note;
              type_version(int w, const std::string& c,const std::string&);
              type_version() = delete;
            } ;
            instruction_table* parent;
            void update_tags() const;
          public:
            type() = delete;
            type(instruction_table*, int bitwidth);
            typedef graph_general<dummy, int, false, type> graph_distance_t;
            proxy<typename T::opid_t> debug_op;
            //TODO index this a bit intelligently...
            /*EAPI*/proxy<std::vector<type_version>> versions;
            /*EAPI*/proxy<std::vector<conversion>> conversions;
            /*EAPI*/proxy<typename T::tid_t> tid;
            /*EAPI*/proxy<int> bitwidth;
            /*IAPI*/void addcode_type(int w, const std::string& c,const std::string&) ;
            /*IAPI*/void addcode_conversion(int from, int to, const std::string& c1, const std::string& c2,const std::string& cc,const std::string& cg, const std::string& n, const std::string& t,int r);
            mutable graph_distance_t distances; //technically taken just a cache
        }
        ;
        class operation //holds general operation traits
        {
          private:
            mutable int imbued_width;
            friend instruction_table;
            struct instruction //holds information for generation
            {
              const int width;
              const int width_in;
              const int width_out;
              const std::string code;
              const std::string code_custom;
              const std::string note;
              const std::string tags;
              const int rating;
              mutable typename T::flag_t satisfactory;
              instruction(int wi, int wo, const std::string& c,const std::string&,const std::string&,const std::string&,int r, bool satisfactory);
              instruction() = delete;
            }
            ;//std::vector<typename T::tid_t> in_types
            struct expansion
            {
              const std::string name;
              const std::string transformer_name;
              const std::vector<typename T::opid_t> arguments;
              const std::string note;
              expansion(const std::string&,const std::string&,const std::vector<typename T::opid_t>&, const std::string&);
              expansion() = delete;
            };
            instruction_table* parent;
            void update_tags() const;
          public:
            /*TAPI*/proxy<std::vector<expansion>> expansions;
            /*EAPI*/proxy<std::vector<instruction>> versions;
            /*EAPI*/proxy<type*> mytype;
            /*EAPI*/proxy<typename T::tid_t> out_type;
            /*EAPI*/proxy<typename std::vector<typename T::tid_t>> in_types;
            /*EAPI*/proxy<typename T::flag_t> flags; /*EAPI*/proxy<typename T::opid_t> opid;
            /*IAPI*/void addcode(int wi, int wo, const std::string& c,const std::string&,const std::string&,const std::string&,int r);
            /*IAPI*/void addexpansion(const std::string&, const std::string&, const std::vector<typename T::opid_t>& args, const std::string&);
            /*API*/bool is(typename T::flag_t f) const ;
            /*API*/int get_max_width(int bound = 1000000000, int* in = NULL, int* out = NULL)const;
            /*API*//*DEPRECATED*///void imbue_width(int w)const;
            /*API*/typename T::opid_t get_debug_opid() const;
            /*API*/bool get_type_string(int w, std::string&)const;
            /*API*/bool get_op_string(int w, std::string& c, std::string& cc, std::size_t&)const;
            /*API*/bool get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string&cc, std::string& type, std::size_t&)const;
            /*API*/const typename type::graph_distance_t& get_conversion_graph() const;
            operation(typename T::opid_t i, typename T::tid_t ot, const std::vector<typename T::tid_t>& it, typename T::flag_t f, type* t, instruction_table* parent);
            operation() = delete;
        }
        ;
        typedef std::map<typename T::tid_t, type*> typetab_t;
        typedef std::map<typename T::opid_t, operation*> instab_t;
        typedef std::set<std::shared_ptr<taghandler_base>> taghandlerrec_t;
        typedef std::vector<taghandlerrec_t> taghandlertab_t;
        taghandlertab_t taglists;
        typename T::flag_t get_tag_mask(const std::string& tags);
      public:
        /*EAPI*/proxy<instab_t> instab;
        /*EAPI*/proxy<typetab_t> typetab;

        typedef operation operation_t; 
        typedef type type_t;
        /*API*/ void add_tags(std::shared_ptr<taghandler_base>,std::size_t layer = gSELECT); 
        /*API*/ void rm_tags(std::shared_ptr<taghandler_base>,std::size_t layer = gSELECT);
        /*API*/ bool is_tag_satisfactory(const std::string&) const;
        /*API*/ void update_tags() const;
        /*API*/ const operation_t& dec(typename T::opid_t type) const ;
        /*API*/ const type_t& dectype(typename T::tid_t type) const ;
        /*IAPI*/ operation_t& addoperation(typename T::opid_t op, typename T::tid_t t, const std::vector<typename T::tid_t>&it, typename T::flag_t f) ;
        /*IAPI*/ type_t& addtype(typename T::tid_t t, int bitwidth = 0) ;
        void clear(bool tags = false) ;
        bool empty();
        ~instruction_table();
    } ;



  typedef instruction_table<traits> instruction_table_default;

  template <class T>
    instruction_table<T>::type::type(instruction_table<T>* p, int bw) : parent(p), bitwidth(bw)
  {
  }

      template <class T>
  void instruction_table<T>::type::update_tags() const
  {
    for(const auto& i : conversions.r())
      i.satisfactory = parent->get_tag_mask(i.tags);
  }
      template <class T>
  void instruction_table<T>::operation::update_tags() const
  {
    for(const auto& i : versions.r())
    {
      i.satisfactory = parent->get_tag_mask(i.tags);
    }
  }

    template <class T>
  typename T::opid_t instruction_table<T>::operation::get_debug_opid() const
  {
    return mytype->debug_op.r();
  }

  template <class T>
    bool instruction_table<T>::empty()
    {
      return instab.r().empty();
    }

  template <class T>
    instruction_table<T>::type::type_version::type_version(int w, const std::string& c,const std::string& n) : width(w), code(c), note(n)
  {
  }

  template <class T>
    instruction_table<T>::type::conversion::conversion(int i, int o, const std::string& c1, const std::string& c2,const std::string& cc, const std::string& cg, const std::string& n,const std::string& t,int r, bool s) : width_in(i), width_out(o), code1(c1), code2(c2), code_custom(cc), code_generic(cg), note(n), tags(t), rating(r), satisfactory(s)
  {
  }

  template <class T>
    void instruction_table<T>::type::addcode_type(int w, const std::string& c,const std::string& n)
    {
      versions.rw().push_back(type_version(w, c,n));
      distances.addvert(w, false, false);
    }

  template <class T>
    void instruction_table<T>::type::addcode_conversion(int in, int out, const std::string& c1,const std::string& c2,const std::string& cc,const std::string& cg, const std::string& n,const std::string& t,int r)
    {
      bool s = parent->is_tag_satisfactory(t);
      conversions.rw().push_back(conversion(in, out, c1, c2,cc,cg,n,t,r, s));
      distances.addvert(in, false, false);
      distances.addvert(out, false, false);
      if(s)
        distances.addedge(in,out);
    }

  template <class T>
    instruction_table<T>::operation::expansion::expansion(const std::string& n, const std::string& t, const std::vector<typename T::opid_t>& a, const std::string& m) : name(n), transformer_name(t), arguments(a), note(m)
  {
  }

  template <class T>
    instruction_table<T>::operation::instruction::instruction(int wi, int wo, const std::string& c,const std::string& cc,const std::string& n,const std::string& t,int r, bool s) : code(c), width_in(wi), width_out(wo), width(std::max(wi, wo)), code_custom(cc), note(n), tags(t), rating(r), satisfactory(s)
  {
  }

  template <class T>
    instruction_table<T>::operation::operation(typename T::opid_t i, typename T::tid_t ot, const std::vector<typename T::tid_t>& it, typename T::flag_t f, type* t, instruction_table<T>* p) : opid(i), mytype(t), out_type(ot), flags(f), parent(p), in_types(it)
  {
  }

  template <class T>
    const typename instruction_table<T>::type::graph_distance_t& instruction_table<T>::operation::get_conversion_graph() const
    {
      (mytype.r())->distances.calculate_distances();
      return mytype.r()->distances;
    }

  template <class T>
    void instruction_table<T>::operation::addexpansion(const std::string& n, const std::string& t, const std::vector<typename T::opid_t>& a, const std::string& m)
    {
      expansions.rw().push_back(expansion(n,t,a,m));
    }

  template <class T>
    void instruction_table<T>::operation::addcode(int wi, int wo, const std::string& c,const std::string& cc,const std::string& n,const std::string& t,int r)
    {
      versions.rw().push_back(instruction(wi, wo, c,cc,n,t,r,parent->is_tag_satisfactory(t)));
    }

  template <class T>
    bool instruction_table<T>::operation::is(typename T::flag_t f) const 
    {
      return (f & flags) > 0;
    }

  template <class T>
    int instruction_table<T>::operation::get_max_width(int bound, int* in, int* out)const
    {
      int w = 0;
      for(const auto& ins : versions.r())
      {
        if(ins.width <= bound && ins.width > w)
        {
          w = ins.width;
          if(in != NULL) *in = ins.width_in;
          if(out != NULL) *out = ins.width_out;
        }
      }
      return w;
    }

  /*
     template <class T>
     void instruction_table<T>::operation::imbue_width(int w)const
     {
     imbued_width = w;
     }
     */

  template <class T>
    bool instruction_table<T>::operation::get_type_string(int w, std::string& c)const
    {
      if(w == -1)
        w = imbued_width;
      for( const auto& t : mytype.r()->versions.r())
      {
        if ( t.width == w)
        {
          c = t.code;
          return true;
        }
      }
      error( std::string("type of width = ").append(std::to_string(w)).append(" at operation ").append(opid).append(" not found"));
      return false;
    }

  template <class T>
    bool instruction_table<T>::operation::get_op_string(int w, std::string& c, std::string& cc, std::size_t& printability)const
    {
      if(w == -1)
        w = imbued_width;
      bool s = false;
      int r = 0;
      for( auto ins : versions.r())
      {
        if ( (ins.satisfactory & mSELECT) && ins.width_in == w && ins.rating >= r)
        {
          c = ins.code;
          cc = ins.code_custom;
          r = ins.rating;
          s = true;
          printability = (ins.satisfactory & mPRINT) ? (ins.satisfactory & mONCE) ? 1 : 100000 : 0;
        }
      }
      if(!s)
      {
        warn( std::string("instruction of width_in = ").append(std::to_string(w)).append(" at operation ").append(opid).append(" satisfying current tags not found"));
        printability = 0;
      }
      return s;
    }

  template <class T>
    bool instruction_table<T>::operation::get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string& cc, std::string& t, std::size_t& printability) const
    {
      bool s = false;
      int r = 0;
      for( auto con : mytype->conversions.r())
      {
        if ((con.satisfactory & mPRINT) && con.width_in == from && con.width_out == to && con.rating >= r)
        {
          c1 = con.code1;
          c2 = con.code2;
          cc = con.code_custom;
          get_type_string(to, t);
          r = con.rating;
          s = true;
          printability = (con.satisfactory & mPRINT) ? (con.satisfactory & mONCE) ? 1 : 100000 : 0;
        }
      }
      //this error would prevent nontrivial path search from being used
      //if(!s)
      //  error( std::string("conversion from width ").append(std::to_string(from)).append(" to ").append(std::to_string(to)).append(" at operation ").append(opid).append(" not found"));
      return s;
    }

  template <class T>
    const typename instruction_table<T>::operation_t& instruction_table<T>::dec(typename T::opid_t type)   const
    {
      return *instab.r().find(type)->second;
    }

  template <class T>
    const typename instruction_table<T>::type_t& instruction_table<T>::dectype(typename T::tid_t type)   const
    {
      return *typetab.r().find(type)->second;
    }

  template <class T>
    typename instruction_table<T>::operation_t& instruction_table<T>::addoperation(typename T::opid_t op, typename T::tid_t t, const std::vector<typename T::tid_t>& it, typename T::flag_t f)
    {
      if(instab.r().find(op) != instab.r().end())
        return *instab.rw().find(op)->second;
      auto itr = typetab->find(t);
      if(itr == typetab->end())
        error(std::string("type '").append(t).append("' not found; at: '").append(op).append("' while constructing graph"));
      operation* ptr = new operation(op, t, it, f, itr->second, this);
      instab.rw()[op] = ptr;
      if((f & fDEBUG) > 0)
      {
        if(it.size() != 1)
          error("debug operation has to have exactly one input");
        typetab->find(it[0])->second->debug_op.rw() = op;
      }
      return *ptr;
    } 

  template <class T>
    typename instruction_table<T>::type_t& instruction_table<T>::addtype(typename T::tid_t t, int bitwidth)
    {
      if(typetab.r().find(t) != typetab.r().end())
      {
        type_t& ret = *typetab.rw().find(t)->second;
        if(bitwidth != 0)
          ret.bitwidth.rw() = bitwidth;
        return ret;
      }
      type* ptr = new type(this, bitwidth);
      ptr->tid = t;
      typetab.rw()[t] = ptr;
      return *ptr;
    }

  template <class T>
    instruction_table<T>::~instruction_table()  
    {
      clear();
    }

  template <class T>
    void instruction_table<T>::rm_tags(std::shared_ptr<taghandler_base> ptr, std::size_t l)
    {
      taglists[l].erase(ptr);
    }

  template <class T>
    void instruction_table<T>::add_tags(std::shared_ptr<taghandler_base> ptr, std::size_t l)
    {
      while(taglists.size() < l + 1)
        taglists.push_back(taghandlerrec_t());
      taglists[l].insert(ptr);
    }

      template <class T>
  typename T::flag_t instruction_table<T>::get_tag_mask(const std::string& tags)
  {
    typename T::flag_t mask = 0; 
    typename T::flag_t def = mSELECT | mPRINT; 
    for(int i = 0; i < gmCOUNT; ++i)
    {
      bool sat = def & (1<<i);
      if(taglists.size() > i)
      {
        sat = true;
        for(auto th : taglists[i])
          sat &= th->is_satisfactory(tags);
      }
      if(sat)
        mask |= 1 << i;
    }
    return mask;
  }

    template <class T>
  bool instruction_table<T>::is_tag_satisfactory(const std::string& tags) const
  {
    if(taglists.empty())
      return true;
    bool sat = true;
    for(auto th : taglists[gSELECT])
      sat &= th->is_satisfactory(tags);
    return sat;
  }

  template <class T>
    void instruction_table<T>::update_tags() const
    {
      for(auto i : instab.r())
        i.second->update_tags();
      for(auto d : typetab.r())
        d.second->update_tags();
    }

  template <class T>
    void instruction_table<T>::clear(bool tags)
    {
      for(auto d : typetab.rw())
      {
        delete d.second;
      }
      for(auto d : instab.rw())
      {
        delete d.second;
      }
      instab.rw().clear();
      typetab.rw().clear();
      if(tags)
        taglists.clear();
    }

  template class instruction_table<traits> ;

}

#endif

