%At this point we would like to examine possibilities of realisation of flow graphs with all types of nodes. 

\label{sec:partitioning}

In the previous sections, we have shown how flow graphs composed of regular operations may be processed. This approach does not suffice in graphs containing control flow since different nodes may need to process data at different speeds. 

Our strategy is to cut a flow graph into partitions such that every partition consists only of regular operations. These partitions are then connected by buffers. Finally, the data are processed by a crawler which  goes through our graph and processes its partitions one at a time. Every single partition is processed by a fragment of code generated by the generators we have already presented. 

First, we need some definitions:

\mybegindef{layer}{Edge layer}
  Let there be a directed graph (possibly multigraph) $G(V,E)$. We will assign one more numeric annotation to every edge. We will call this annotation \emph{layer}. Thus, we have $\mf{layer}: E \arrow \N_0$. If $\mf{layer}(e) = n$ we will say that $e$ is on layer $n$. 
\myenddef

Layer will denote a type of an edge. It will allow us to talk about subsets of edges in a more intuitive manner and also to introduce more complex graph structure. We show our visual convention in Figure \ref{fig:lines}.

\graph{lines}{Our convention of marking edge layers}

\mybegindef{factorgraph}{Factor graph}
  Let $G(V,E)$ be a directed multigraph and $G_f(V_f \subseteq \powerset(V),E_f)$ be a directed graph. We will say that $G_f$ is a \emph{factor graph} of $G$ if there exists a function $f: V \arrow V_f$ such that:
  \begin{itemize}
    \item $(\forall u \in V)(\forall c \in V_f)( u \in c \Longleftrightarrow c = f(u)) $
    \item $f(u) = f(v)$ if and only if there exists an undirected path $P_{u,v}$ in $G$ which uses only edges on layer 0
    \item $(\exists e \in E)(\exists u,v \in V)(e \sim (u,v) \land layer(e) = 1) \Longleftrightarrow \exists(e_f \in E_f)( e_f \sim (f(u), f(v)) )$  
    \item The edge $e_f$ in the previous condition is unique.
  \end{itemize}
  We will call vertices of $G_f$ \emph{components} since they are connected components in a graph defined by $(V, \{e \in E \mid layer(e) = 0 \})$. We will also use the term \emph{component} for partitions of $G$ which correspond to a vertex in the factor graph. I.e., we will call a partition $P$ of $G$ a component if and only if there $(\exists w \in V_f)$ s.t. $(x \in P) \Longleftrightarrow ( f(x) = w)$ for every $x \in V$.
\myenddef

\begin{rem} 
  We should warn the reader that due to this definition the terms \emph{component}, \emph{partition} and \emph{class (of equivalence relation)} cohere.
\end{rem}

\mybegindef{componentio}{Input and output vertex of a component}
  Let $C$ be a component of a graph $G(V,E)$. We will use the term \emph{input vertex of a component} for a vertex $v \in C$ s.t. $(\exists w \in V)(\exists e \in E)( e \sim (w,v) \land \mf{layer}(e) \geq 1 )$. We will also use the term \emph{output vertex of a component} defined analogically.
\myenddef

Note that this definition overrides another meaning of this term. Also, note that a factor graph exists for \emph{every} graph and that it is unique (up to isomorphism). This is true since factor graphs are determined by components of connectedness.

Our partitioning consists of the following steps:
\begin{enumerate}
  \item Control flow node expansion. 
  \item Removal of cycles in factor graph. 
\end{enumerate}

Cycles may be introduced into factor graphs by node expansion, even into factor graphs of acyclic flow graphs. Any path in a factor graph represents a path of buffers where data wait for processing. Thus, a cycle in a factor graph means that some computation path (let us say $P$) containing some control flow nodes leaves a component (let us say $C$) and later joins it. This prevents the partition from being processed by a single basic block of code. Therefore, we need to remove all cycles from the factor graph. We do so by splitting the component $C$ into two new components $C_1$ and $C_2$ such that $C_1 \leq P \leq C_2$.

In other words, we need to achieve a factor graph with a topological ordering in its semantical meaning. That is, we need to achieve a situation in which partition may be processed in some order and we need this order to be realisable. We do not prohibit cycles entirely, since a cycle whose first iteration does not depend on data from cyclical edges does not create a dependency. If we wished to be overly formal, we could introduce a construct which would understand every node as a set of its instances. These instances would be induced by every iteration of this algorithm. Apparently, every graph created by such construction is acyclic and thus has a topological ordering in its standard, formal meaning.

\subsubsection{Node expansion}

In this step, we replace all control flow nodes by new vertices which are connected by layer 1 and 2 edges. By this, we insert splits at places where data need to be reordered (where the corresponding streams need to be either split or merged). We formalise this by Definition \ref{def:cfexpansions}.

\mybegindef{cfexpansions}{Control flow node expansions}
We shall define expansions of control flow nodes introduced in Definition \ref{def:nodetypes1} by Figure \ref{fig:expansions_queue}. I.e., we define node expansion as a process which substitutes nodes in a graph by subgraphs defined by Figure \ref{fig:expansions_queue}. Edges incident to an expand node are preserved during this process.
\graphplain{expansions}
\graphplain{expansions_mergeloop}
\graphplain{expansions_condition}
\graphplain{expansions_split}
\graph{expansions_queue}{Diagrams defining node expansion (Definition \ref{def:cfexpansions}).}
\myenddef

\subsubsection{Cycle removal}

Let $G(V,E)$ be a flow graph. In order to process data, we need the factor graph $H$ of $G$ to be acyclic. Unfortunately, $H$ may contain cycles and loops in spite of $G$ (restricted to layer 0 and 1 edges) being acyclic. 


We propose Algorithm \ref{alg:cycleremalg} to split components so that cycles get removed. 

Ignoring some details, this algorithm proceeds as follows:
\begin{enumerate}
  \item Take a queue which is on any cycle.
  \item Colour its predecessors green.
  \item Colour its successors red.
  \item Colour other vertices somehow.
  \item Cut the problematic component along the green-red borderline.
  \item Repeat.
\end{enumerate}

\mybeginalg{cycleremalg}{Cycle removal algorithm}\ \
\begin{samepage}
\begin{code}
  H = G
while ( cycle in H exists )     
{ //loop i
  colour vertices of G black
  C = any component on cycle in a factor graph of H
  for v in all outputs of C     
  { //loop j
    for w s.t. there a is path from v to w 
    (using edges on layers 0 and 1)
    {
      colour w red;
    }

    colour v and all non-red inputs of C green;
    for w non-red s.t. there is a path from w to a green vertex
    (using edges on layers 0 and 1)
    {
      colour w green;
    }

    for w non red s.t. there is an undirected path from w to v
    (using edges on layers 0 not containing red vertices)
    { //loop k
      colour w green;
    }

    bool changed = false;
    for edge (w,x) s.t. w is green and x is red
    {
      put and expand an explicit queue on (w,x) in H;
      changed = true;
    }
    if(changed)
      break;
  }
}
\end{code}
\end{samepage}
\myendalg

\mybeginclaim{partitioningproof}{Functionality of the cycle removal algorithm}
  Let $G$ be a flow graph consisting of node types defined so far with control flow nodes expanded. Perform Algorithm \ref{alg:cycleremalg} on $G$. We claim that:
  \begin{enumerate}
    \item The algorithm terminates.
    \item The algorithm yields a graph $H$ whose factor graph contains neither loops nor cycles.
  \end{enumerate}
  \begin{proof}
    Let $K$ be a cycle or a loop in a factor graph of $G$ and let $C \in K$ ($C$ from algorithm).
    \begin{itemize}
      \item There exists an oriented path $P$ on layers 0 and 1 from some $a$ to some $b$ s.t. $a \neq b$ are two distinct vertices in the same component. $P$ exists due to the existence of $K$. Non-equal $a$ and $b$ exist because $G$ (restricted to layers 0 and 1) is acyclic and so $P$ cannot lead from $a$ to $a$. 
      \item If we choose $v \in P$ s.t. $v \neq b$ ($v$ from algorithm), then $b$ will be coloured red. Otherwise $a$ will be chosen as $v$ in another iteration since $a$ and $b$ are in the same component. Thus, $b$ will be coloured red in some iteration of loop j.  Moreover, $a$ will be coloured green in the same iteration since there is no path from $b$ to $a$.
      \item Since $a$ and $b$ are in the same component, every path from $a$ to $b$ will be disconnected. Thus, the algorithm works if it terminates. 
  \item Putting a queue on an edge does not introduce any new path on level 0 between vertices of $G$ in $H$. It also decreases the number of paths on level 0 in $H$ between vertices of $G$. There are finitely many such paths in $G$. Thus, the algorithm will terminate.
    \end{itemize}
  \end{proof}
\myendclaim

\begin{rem}
  The algorithm will not terminate if there is a cycle composed of 0 and 1 layer edges. But we have defined node expansion so that all backwards edges are on layer 2.
\end{rem}

This algorithm is not optimal. The loop marked as \ttt{k} may be replaced by a minimum cut algorithm, by which the size of the first cut may be minimised. Unfortunately, there is no guarantee that such optimisation does not increase the minimum costs of cuts performed later. If we wanted an optimal solution, all cuts would have to be optimised at the same time. 


As an example of the entire partitioning process, we show a simple computation (Figure \ref{fig:partitioning0}) which performs some arithmetic operations. The reader will surely excuse empty branch bodies (direct edges from the split node to merge the merge node). We begin by a simple representation of a graph which contains split and merge control flow nodes and one explicitly inserted queue (the \emph{buffer} node).

Node expansion produces a new graph (Figure \ref{fig:partitioning1}) with some level 1 edges. This graph already consists of four components, but there are some edges which bypass the control flow. These edges introduce a data dependency in the partition 0 which cannot be met without leaving the code dedicated to processing of the partition 0. This problem may be seen in the included factor graph, which contains an edge going from component 3 to component 0. There is also a loop on partition 0 caused by the edges which bypass the buffer node. 

Finally, the cycle removal inserts the \emph{auto buffer} nodes, producing a graph (Figure \ref{fig:partitioning2}) with neither cycles nor loops in its factor graph.

\graph{partitioning0}{An example of control flow prior to any transformation.}
\graph{partitioning1}{The graph from Figure \ref{fig:partitioning0} after node expansion.}
\graph{partitioning2}{The graph from Figure \ref{fig:partitioning1} after cycle removal.}

