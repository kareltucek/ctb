%At this point we would like to examine possibilities of realisation of flow graphs with all types of nodes. 

\label{sec:partitioning}

In the previous sections, we have shown how flow graphs composed of regular operations may be processed. This approach does not suffice in graphs containing control flow since different nodes may need to process data at different speeds. 

Our strategy is to cut a flow graph into partitions such that every partition consists only of regular operations. These partitions are then connected by some buffers. Finally, the data are processed by a crawler which  goes through our graph and processes its partitions one at a time. Every single partition is processed by a fragment of code generated by the generators we have already presented. 

First, we need some definitions.

\mybegindef{layer}{Edge layer}
  Let there be a directed graph (possibly multigraph) $G(V,E)$. We will assign one more numeric annotation to every edge. We will call this annotation \emph{layer}. Thus, we have $layer: E \arrow \N_0$. If $layer(e) = n$ we will say that $e$ is on layer $n$. 
\myenddef

Layer will denote a type of an edge. It will allow us to talk about subsets of edges in a more intuitive manner and also to introduce more complex graph structure. We show our visual convention in the following picture.

\graph{lines}{Our convention of marking edge layers}

\mybegindef{factorgraph}{Factor graph}
  Let $G(V,E)$ be a directed multigraph and $G_f(V_f \subseteq \powerset(V),E_f)$ be a directed graph. We will say that directed graph $G_f$ is a \emph{factor graph} of $G$ if there exists a function $f: V \arrow V_f$ such that:
  \begin{itemize}
    \item $(\forall u \in V)(\forall c \in V_f)( u \in c \Longleftrightarrow c = f(u)) $
    \item $f(u) = f(v)$ if and only if there exists an undirected path $P_{u,v}$ in $G$ which uses only edges on layer 0.
    \item $(\exists e \in E)(\exists u,v \in V)(e \sim (u,v) \land layer(e) = 1) \Longleftrightarrow \exists(e_f \in E_f)( e_f \sim (f(u), f(v)) )$  
    \item The edge $e_f$ in the previous condition is unique.
  \end{itemize}
  We will call vertices of $G_f$ \emph{components} since they are connected components in a graph defined by $(V, \{e \in E \mid layer(e) = 0 \})$. We will also use the term \emph{component} for partitions of $G$ which correspond to a vertex in the factor graph. I.e., we will call a partition $P$ of $G$ a component if and only if there $(\exists w \in V_f)$ s.t. $(x \in P) \Longleftrightarrow ( f(x) = w)$ for every $x \in V$.
\myenddef

\begin{rem} 
  We should warn the reader that due to this definition the terms \emph{component}, \emph{partition} and \emph{class (of equivalence relation)} cohere.
\end{rem}

\mybegindef{componentio}{Input and output vertex of a component}
  Let $C$ be a component of a graph $G(V,E)$. We will use the term \emph{input vertex of a component} for a vertex $v \in C$ s.t. $(\exists w \in V)(\exists e \in E)( e \sim (w,v) \land layer(e) \geq 1 )$. We will also use the term \emph{output vertex of a component} defined analogically.
\myenddef

Note that this definition overrides another meaning of this term. Also, note that a factor graph exists for every graph and that it is unique (up to isomorphism).

Our partitioning consists of the following steps:
\begin{enumerate}
  \item Control flow node expansion. 
  \item Removal of cycles in factor graph. 
\end{enumerate}

Cycles may be introduced into factor graphs by node expansion, even into factor graphs of acyclic flow graphs. Any path in a factor graph represents some path of buffers where data wait for processal. A cycle in a factor graph means that some computation path (let us say $P$) containing some control flow nodes leaves a component (let us say $C$) and later joins it. We need to remove all cycles from the factor graph since we want to process components of the resulting graph in a single processing body. We do so by splitting the component $C$ into two new components $C_1$ and $C_2$ such that $C_1 \leq P \leq C_2$.

\subsubsection{Node expansion}

In this step, we replace all control flow nodes by new vertices which are connected by layer 1 and 2 edges. By this, we insert splits at places where data need to be reordered (where the corresponding streams need to be either split or merged). We show expansions in the following picture.

\mybegindef{cfexpansions}{Control flow node expansions}
We shall define expansions of the control flow node types introduced in definition \ref{def:nodetypes1} by the following diagrams.
\graphplain{expansions}
\graphplain{expansions_mergeloop}
\graphplain{expansions_condition}
\graphplain{expansions_split}
\graphplain{expansions_queue}
\myenddef

\subsubsection{Cycle removal}

Let $G(V,E)$ be a flow graph. In order to process data, we need a factor graph $H$ of $G$ to be acyclic. Unfortunately, $H$ may contain cycles and loops even though $G$ (restricted to layer 0 and 1 edges) is acyclic. 


We propose the algorithm \ref{alg:cycleremalg} to split components so that cycles get removed. 

\mybeginalg{cycleremalg}{Cycle removal algorithm}\ \
\begin{samepage}
\begin{code}
  H = G
while ( cycle in H exists )     
{ //loop i
  colour vertices of G black
  C = any component on cycle in a factor graph of H
  for v in all outputs of C     
  { //loop j
    for w s.t. there a is path from v to w 
    (using edges on layers 0 and 1)
    {
      colour w red;
    }

    colour v and all nonred inputs of C green;
    for w nonred s.t. there is a path from w to a green vertex
    (using edges on layers 0 and 1)
    {
      colour w green;
    }

    for w nonred s.t. there is an undirected path from w to v
    (using edges on layers 0 not containing red vertices)
    { //loop k
      colour w green;
    }

    bool changed = false;
    for edge (w,x) s.t. w is green and x is red
    {
      put and expand an explicit queue on (w,x) in H;
      changed = true;
    }
    if(changed)
      break;
  }
}
\end{code}
\end{samepage}
\myendalg

Ignoring some details this algorithm proceeds as follows:
\begin{enumerate}
  \item Take a queue which is on any cycle.
  \item Colour its predecessors green.
  \item Colour its successors red.
  \item Colour other vertices somehow.
  \item Cut the problematic component along the green-red borderline.
  \item Repeat.
\end{enumerate}

\mybeginclaim{partitioningproof}{Functionality of the cycle removal algorithm}
  Let $G$ be a flow graph consisting of node types defined so far with control flow nodes expanded. Perform algorithm \ref{alg:cycleremalg} on $G$. We claim that:
  \begin{enumerate}
    \item The algorithm terminates.
    \item The algorithm yields a graph $H$ whose factor graph contains neither loops nor cycles.
  \end{enumerate}
  \begin{proof}
    Let $K$ be a cycle or a loop in a factor graph of $G$ and let $C \in K$ ($C$ from algorithm).
    \begin{itemize}
      \item There exists an oriented path $P$ on layers 0 and 1 from some $a$ to some $b$ s.t. $a \neq b$ are two distinct vertices in the same component. $P$ exists due to the existence of $K$. Nonequal $a$ and $b$ exist because $G$ (restricted to layers 0 and 1) is acyclic and so $P$ cannot lead from $a$ to $a$. 
      \item If we choose $v \in P$ s.t. $v \neq b$ ($v$ from algorithm), then $b$ will be coloured red. Otherwise $a$ will be chosen as $v$ in another iteration since $a$ and $b$ are in the same component. Thus, $b$ will be coloured red in some iteration of loop j.  Moreover, $a$ will be coloured green in the same iteration since there is no path from $b$ to $a$.
      \item Since $a$ and $b$ are in the same component, every path from $a$ to $b$ will be disconnected. Thus, the algorithm works if it terminates. 
  \item Putting a queue on an edge does not introduce any new path on level 0 between vertices of $G$ in $H$. It also decreases the number of paths on level 0 in $H$ between vertices of $G$. There are finitely many such paths in $G$. Thus, the algorithm will terminate.
    \end{itemize}
  \end{proof}
\myendclaim

\begin{rem}
  The algorithm will not terminate in case there is a cycle composed of edges on layers 0 and 1. But we have defined node expansion so that all backwards edges are on layer 2.
\end{rem}

This algorithm is not optimal. The loop marked as \ttt{k} may be replaced by a minimum cut algorithm, by which the size of the first cut may be minimised. Unfortunately, there is no guarantee that such optimisation will not increase the minimum costs of the cuts performed later. If we wanted an optimal solution, all cuts would have to be optimised at the same time. 


As an example of the entire partitioning process, we show a simple pipeline (figure \ref{fig:partitioning0}) which performs some arithmetic operations. The reader will surely excuse empty branch bodies (direct edges from split to merge). We begin by a simple representation of a graph which contains split and merge control flow nodes and one explicitly inserted queue (the \emph{buffer} node).

Node expansion produces a new graph (figure \ref{fig:partitioning1}) with some level 1 edges. This graph already consists of 4 components, but there are some edges which bypass the control flow. These edges introduce a data dependency in the partition 0 which cannot be met without leaving the code dedicated to processal of the partition 0. This problem may be seen in the included factor graph, which contains an edge going from component 3 to component 0. There is also a loop on partition 0 caused by the edges which bypass the buffer node. 

Finally, the cycle removal inserts the \emph{auto buffer} nodes, producing a graph (figure \ref{fig:partitioning2}) with neither cycles nor loops in its factor graph.

\graph{partitioning0}{Example of control flow prior to any transformation}
\graph{partitioning1}{Graph from figure \ref{fig:partitioning0} after node expansion}
\graph{partitioning2}{Graph from figure \ref{fig:partitioning1} after cycle removal}

