At this point we would like to examine possibilities of realization of flow graphs with all types of nodes. 

\parspace

In the previous section we have shown how pipelines composed of regular operations may be processed. This approach does not suffice since different nodes may need to process data at different speeds. 

\parspace

\FloatBarrier

Our strategy is to cut the flow graph into partitions such that every partition consists only of regular operations. Then we add buffers between these partitions. The data will then be processed by a crawler which will go through our graph and process its partitions one at a time. Every single partition will be processed by code generated by generators we have already presented. 

\parspace

First, we will need some definitions.

\begin{define}[edge layer]
Let there be a graph (possibly directed multigraph) $G(V,E)$. We will assign one more numeric annotation to every edge. We will call this annotation \emph{layer}. Thus we have $layer: E \arrow \N_0$. If $layer(e) = n$ we will say that $e$ is on layer $n$.
\end{define}

Layer will denote type of edge. It will allow us to talk about subsets of edges in a more intuitive manner and also to introduce a more complex graph structure. We show our visual convention in the following picture.

\graph{lines}

\begin{define}[factor graph]
  Let $G(V,E)$ be a graph (possibly directed multigraph) and $G_f(V_f \subseteq \wp(V),E_f)$ be a directed graph. We will say that $G_f$ is a \emph{factor graph} of $G$ if there exists a function $f: V \arrow V_f$ such that:
  \begin{itemize}
    \item $(\forall u \in V)(\forall c \in V_f)( u \in c \Longleftrightarrow c = f(u) $
    \item $f(u) = f(v)$ if and only if there exists an undirected path $P_{u,v}$ in $G$ which uses only edges on layer 0.
    \item $\exists(e =: (u,v) \in E)(layer(e) = 1) \Longleftrightarrow \exists(e_f \in E_f)( e_f = (f(u), f(v)) )$  
    \item The edge $e_f$ in the previous condition is unique.
  \end{itemize}
  We will call vertices of $G_f$ \emph{components} since they are connected components in graph defined by $(V, \{e \in E \mid layer(e) = 1 \})$. We will also use the term \emph{component} for partitions of $G$ which correspond to a vertex in the factor graph. I.e., we will call a partition $P$ of $G$ a component if and only if there $(\exists w \in V_f)$ s.t. $(x \in P) \Longleftrightarrow ( f(x) = w)$
\end{define}

\begin{define}
  Let $C$ be a component of a graph $G(V,E)$. We will use the term \emph{input vertex of a component} for a vertex $v \in V$ s.t. $(\exists w \in V)(\exists e \in E)( e = (w,v) \land layer(e) \geq 1 )$. We will also use the term \emph{output vertex of a component} defined analogically.
\end{define}

Note that this definition overrides another meaning of this term. Also note that all factor graphs of a graph $G$ are isomorphic.

\parspace

Our partitioning will consist of the following steps:
\begin{enumerate}
  \item Control flow node expansion.
  \item Cycle removal in factor graph.
\end{enumerate}

\subsubsection{Node expansion}

In this step we will replace all control flow nodes by new vertices which will be connected by layer 1 and 2 edges. By this we will insert splits at places where data need to be reordered (where the corresponding streams need to be either split or merged). We show expansions in the following picture.

\graph{expansions}
\graph{expansions_mergeloop}
\graph{expansions_split}
\graph{expansions_queue}

\subsubsection{Cycle removal}

Let $G(V,E)$ be a flow graph with expanded control flow nodes.  In order to process data we will need a factor graph $H$ of $G$ to be acyclic. Unfortunately $H$ may contain cycles and loops even though $G$ (restricted to layer 0 and 1 edges) is acyclic. We propose the following algorithm.

\begin{samepage}
\begin{code}
  H = G
while ( cycle in H exists )     
{ //loop i
  colour vertices of G black
  C = any component on cycle in a factor graph of H
  for v in all outputs of C     
  { //loop j
    for w s.t. there is path from v to w 
    (using edges on layers 0 and 1)
    {
      colour w red;
    }

    colour v and all nonred inputs of C green;
    for w nonred s.t. there is path from w to a green vertex
    (using edges on layers 0 and 1)
    {
      colour w green;
    }

    for w nonred s.t. there is an undirected path from w to v
    (using edges on layers 0 not containing red vertices)
    { //loop k
      colour w green;
    }

    bool changed = false;
    for edge (w,x) s.t. w is green and x is red
    {
      put and expand an explicit queue on (w,x) in H;
      changed = true;
    }
    if(changed)
      break;
  }
}
\end{code}
\end{samepage}

\begin{claim}
  Let $G$ be a flow graph. Perform the previous algorithm on $G$. We claim that:
  \begin{enumerate}
    \item Algorithm will terminate.
    \item Algorithm will yield a graph $H$ whose factor graph will contain neither loops nor cycles.
  \end{enumerate}
  \begin{proof}
    Let $K$ be a cycle or a loop in factor graph of $G$ and let $C \in K$ ($C$ from algorithm).
    \begin{itemize}
      \item There exists an oriented path $P$ from some $a$ to some $b$ s.t. $a$ and $b$ are two distinct vertices in the same component. This holds because $G$ (restricted to layers 0 and 1) is acyclic.
      \item If we choose $v \in P$ s.t. $v \neq b$ ($v$ from algorithm), then $b$ will be coloured red. Otherwise $a$ will be chosen as $v$ in another iteration since $a$ and $b$ are in the same component. Thus $b$ will be coloured red in some iteration of loop j.  Moreover, $a$ will be coloured green in the same iteration.
      \item Since $a$ and $b$ are in the same component, every path from $a$ to $b$ will be disconnected. Thus, the algorithm works if it terminates. 
    \end{itemize}
      Putting a queue on an edge does not introduce any new path on level 0 between vertices of $G$ in $H$. It also decreases number of paths on level 0 edges in $H$ between vertices of $G$. There is finitely many such paths in $G$. Thus, the algorithm will terminate.
  \end{proof}
\end{claim}

\begin{rem}
  The algorithm will not terminate in case there is a cycle composed of edges on layers 0 and 1. But that is prohibited by the definition of a \emph{flow graph}.
\end{rem}

This algorithm is not optimal. The loop $k$ may be replaced by a minimum cut algorithm, by which the size of the first cut may be minimized. Unfortunately there is no guarantee that such optimization will not increase the minimum costs of the cuts performed later. If we wanted an optimal solution, all cuts would have to be optimized at the same time. 

\parspace

As an example we will show a simple pipeline which performs some arithmetic operations. Reader will surely excuse empty branch bodies. We will begin with a simple representation:

\graph{partitioning0}

Node expansion will produce:

\graph{partitioning1}

Finally the cycle removal inserts the \emph{auto buffer} nodes:

\graph{partitioning2}

