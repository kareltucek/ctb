\section{Implemented functinality}

We implement a rather general framework with the following features and properties:
\begin{itemize}
  \item Input is provided by means of two text files --- a graph and an instruction table. The graph file describes structure of a graph similar to the definition of a \emph{flow graph} (definition \ref{def:flowgraph). The instruction table describes general properties of instruction and provides \emph{instruction patterns} which are used to generate the actual code. The patterns are to be in a dollar shell-like expansion format described in section \sec{sec:preprocessor}.
  \item We implement a vectorized generator of regular instructions as described by algorithm \ref{alg:vectorgenerator}. Indirect width conversions (already discussed in section \ref{sec:shortpaths}) are solved by of shortest paths with respect to the set of already generated paths. Our implementation provides output in C language, but may be also easily refined to another languages and environments.
  \item Furthermore, we implement the order-preserving solution of branching graphs as described by algorithm \ref{alg:crawler}. \emph{Node expansion} and \emph{cycle removal} (both discussed in section \ref{sec:partitioning}) are implemented via a general mechanism of graph transformers. Buffer sizes ace assigned according to algorithm \ref{alg:balancer}.
  \item Example instruction table covering the C language via Intel's Streaming Simd Extensions is provided. This table has been satisfyingly tested using autogenerated testing graphs and a testing environment.
  \item We also provide testing features as described in section \ref{sec:testing}. 
  \item There are 16 test scenarios which are designed to ensure correctness of implementation and also to serve as an example of use.
  \item Command-line frontend executable is provided. This frontend may be simple extended by custom commands, graph transformations etc.
  \item We provide implementation of 4 different output environments, i.e., four different forms of the resulting code fragment. Three provide support only for graphs consisting of regular instructions. Two of these are intended for testing purposes and one provides a bobox specific interface . The last one implements control flow and provides an output with an environment-independent interface. The control flow (`cf') environment is also meant to be further composed with other environments since its contains a lot of functionality which may be seen as `core' functionality.
\end{itemize}

