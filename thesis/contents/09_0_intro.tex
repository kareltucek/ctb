\section{Implemented functionality}

We implement a rather general framework with the following features and properties:
\begin{itemize}
  \item The input is provided by means of two text files (or text streams) --- a graph and an instruction table. The graph file describes the structure of a graph similar to the definition of a \emph{flow graph} (Definition \ref{def:flowgraph}). The instruction table describes general properties of instructions and provides \emph{instruction patterns} which are used to generate the actual code. The patterns are to be in a dollar shell-like expansion format which is described in Section \ref{sec:preprocessor}.
  \item We implement a vectorised generator of regular instructions as described by Algorithm \ref{alg:vectorgenerator}. Indirect width conversions (already discussed in Section \ref{sec:shortpaths}) are solved by search for the shortest paths with respect to the set of already generated paths. Our implementation provides output in C language, but may be also easily refined to other languages and environments.
  \item Furthermore, we implement the order-preserving solution of branching graphs as described by Algorithm \ref{alg:crawler}. \emph{Node expansion} and \emph{cycle removal} (both discussed in Section \ref{sec:partitioning}) are implemented via a general mechanism of graph transformers. Buffer sizes are assigned according to Algorithm \ref{alg:balancer}.
  \item Example instruction table covering the C language via Intel's Streaming SIMD Extensions is provided. This table has been satisfyingly tested, using degenerated testing graphs and a testing environment.
  \item We also provide testing features as described in Section \ref{sec:testing}. 
  \item There are 16 test scenarios which are designed to ensure correctness of the implementation and also to serve as examples of use.
  \item Command-line frontend executable is provided. This frontend may be simply extended by custom commands, graph transformations etc.
  \item We provide implementation of four different output environments, i.e., four different forms of the resulting code fragment. Three provide support only for graphs consisting of regular instructions. Two of these are intended for testing purposes and one provides a Bobox-specific interface. The last one implements control flow and provides an output with an environment-independent interface. The control flow (`cf') environment is also meant to be further composed with other environments since it contains functionality which may partially be seen as `core' functionality.
\end{itemize}

