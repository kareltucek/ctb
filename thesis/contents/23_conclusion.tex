We have provided basic formalism describing our problem (in Section \ref{sec:definitions}). Furthermore, we have analysed the problem of flow graphs and provided some relevant observations and proofs. We have shown how basic blocks can be easily vectorised in the domain of our problem (Section \ref{sec:codegeneration}). Moreover, we have shown that order-preserving processing of data is problematic in case of networks with branching (Section \ref{sec:crawler}). We have also shown that order-preserving processing inhibits vectorisation of loops (Section \ref{sec:crawler}). Also, we have attempted to provide a solution which would not preserve order of data (\ref{sec:unordered}). This attempt (which we understand as mostly successful) has shown that other problems arise when the ordering condition is dropped. Although not without significant overhead, we have provided an approach which promises fully vectorised processing of networks containing loops. There still remains an uninvestigated question of how exactly the out-of-order solution should be employed, how this solution should be optimised and how networks should be preprocessed.

Besides theory, we have provided a general framework which provides all important features for realisation of these networks. Our implementation handles vectorisation of networks without control flow (as discussed in Section \ref{sec:codegeneration}) and also implements the basic order-preserving branching version of the problem with all necessary transformations (as described by sections \ref{sec:partitioning} and \ref{sec:crawler}). We have included many user-convenience and testing-related functionality such as testing commands, debugging reports utilising graph visualisations, generators of testing graphs and a wide variety of testing scenarios which serve also as usage examples.  Also, our framework may be easily extended by new functionality and may be adapted to new languages, environments and approaches. 

Additionally, we have provided an instruction table covering the C language via intrinsic SSE instructions (as described by Chapter \ref{ch:sse}). We have managed to test this table satisfyingly using the mechanism described in Section \ref{sec:testing}. We have also developed a family of mechanisms which allow reasonably efficient description and testing of instruction tables. This instruction table, despite being quite complete, is still rather an example of use than a guaranteed, finished and fully-optimised product. Despite thorough testing which employed automatically generated graphs covering the entire table (which currently consists of 1197 records), there still may be bugs. Also, there are optimisation reserves, especially in case of control flow which we have managed to provide only in non-vectorised versions due to reasons discussed in Section \ref{sec:buffer} . 

Our conclusion is that this framework has been satisfyingly tested and that it produces reasonable results. (At least according to benchmarks presented in Section \ref{sec:bench}.)

