\section{Actual implementation of the generator}

The generator is implemented according to the scheme described by algorithm \ref{alg:vectorgenerator}.  Besides that, the generator provides the writer with a consistent context retrieved from the input graph and the instruction table as described in section \ref{sec:instab}. The problem of indirect width conversions is solved by generation of shortest paths. All other functionality lays either directly or indirectly in alias environments and instruction patterns. (Or is an implementation detail)

We should explain one more thing, related to the api of the generator. The generator is actually parametrized by a multilayer writer (created by means of one of the previously described implicit containers) and also by a configuration which specifies how the layers should behave. There are options which allow some layers to receive input only from the first instance of an instruction or receive only the first string written. This allows the generator to output an arbitrary number of code fragments per every single basic block. The former option may be used for simple accumulation of conditions related to control flow semantics of control flow nodes. The latter may be used for indication of presence of specific instructions of for indication of conditions whose value is not operation-specific.




\section{Summary}

We have already described all significant functionality of our framework. The next chapters describe only implementation details. The reader should now think over all introduced concepts and the architecture of our framework. Indeed, we have designed a framework which can perform all needed steps to output results equivalent to the algorithm \ref{alg:crawler}:
\begin{itemize}
  \item Our framework can generate vectorized basic blocks as proposed by algorithm \ref{alg:vectorgenerator}.
  \item The framework can parititon the graph as described in section \ref{sec:partitioning}:
  \begin{itemize}
    \item Node expansion may be performed by use of a graph transformer whose input is described by expansions.
    \item Cycle removal is implemented according to algorithm \ref{alg:cycleremalg} by means of a graph transformer.
  \end{itemize}
  \item Code of a partition, as described by algorithm \ref{alg:crawler}, may be generated by a custom alias environment. This environment would contain a static template of this partition with placeholders in place of all conditional jumps specified by the algorithm. As proposed, the control flow nodes may accumulate their control-flow related conditions into named layers of the writer. Substituting these accumulated values into the template is then a simple procedure consisting of a single call to a new writer.
  \item Other generic procedures, such as buffers may be implemented either externally in the C preprocessor or by means of alias environments. Either implementation is the interfaced via records in an instruction table. We employ the latter way due to stubborn recursion-rejectiveness of the C preprocessor\footnote{Recursion may actually be achieved by means of various workarounds. Unforunately, the implemented algorithms tend to fail due to obscure reasons.}. Specifically, we implement an in-register SSE buffer in the the `cf\_macros' environment.
\end{itemize}
