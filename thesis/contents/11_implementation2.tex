\section{Actual implementation of the generator}

\begin{itemize}
  \item The generator is implemented according to the scheme described by Algorithm \ref{alg:vectorgenerator}. (The main body is contained in \ttt{generator::data\_t::generate} method in \ttt{generator.h}.)
  \item The generator provides the writer with a consistent context retrieved from the input graph and the instruction table as described in Section \ref{sec:instab}. 
  \item The problem of indirect width conversions is solved by generation of shortest paths from the set of already generated widths. (Width conversions are handled by the \ttt{generator::data\_t::get\_access} method which is to be found in \ttt{generator.h})
  \item Types of operations are strictly checked. Expansions are chosen according to the type signature of incoming edges of a node and are also type-checked. The exact expansion is determined by types of incoming edges. The implicit type inference is not required to know all types to decide upon exact expansion due to possible problems with looped dependencies. In such case, a unique matching expansion is found and used. If there is an ambiguity found, a warning is thrown and an arbitrary expansion chosen. The type inference works by assigning types to edges in one topological pass upon graph load and is recalculated upon every transformation. This way transformations have full information about types (otherwise, multiple executions of transformations would be required). Type inference and check takes place in \ttt{generator::data\_t::infer\_type} (\ttt{generator.h}). Expansion selection is implemented by means of \ttt{instruction\_table::find\_expansion} methods of instruction table (\ttt{instructions.h}).
  \item All other functionality lays either directly or indirectly in alias environments and instruction patterns (or is an implementation detail).
\end{itemize}

We should explain one more thing, related to the API of the generator. The generator is actually parametrised by a multilayer writer (created by means of one of the previously described implicit containers) and also by a configuration which specifies how the layers should behave. There are options which allow some layers to receive input only from the first instance of an instruction or to receive only the first string written. This allows the generator to output an arbitrary number of code fragments per every single basic block. The former option may be used for simple accumulation of conditions related to control flow semantics of control flow nodes. The latter may be used for indication of presence of specific instructions or for indication of conditions whose value is not operation-specific.

\section{Summary}

We have already described all significant functionality of our framework. The next chapters describe only implementation details. The reader should now think over all introduced concepts and the architecture of our framework. Indeed, we have designed a framework which can perform all needed steps to output results equivalent to Algorithm \ref{alg:crawler}:
\begin{itemize}
  \item Our framework can generate vectorised basic blocks as proposed by Algorithm \ref{alg:vectorgenerator}.
  \item The framework can partition the graph as described in Section \ref{sec:partitioning}:
  \begin{itemize}
    \item Node expansion may be performed by use of a graph transformer whose input is described by expansions. (This is implemented in \ttt{cf\_transform.h}.)
    \item Cycle removal is implemented according to Algorithm \ref{alg:cycleremalg} by means of a graph transformer. (This is implemented in \ttt{cf\_transform.h}.)
  \end{itemize}
\item Code of a partition, as described by Algorithm \ref{alg:crawler}, may be generated by a custom alias environment. This environment would contain a static template of this partition with placeholders in place of all conditional jumps specified by the algorithm. As proposed, the control flow nodes may accumulate their control-flow related conditions into named layers of the writer. Substituting these accumulated values into the template is then a simple procedure consisting of a single call to a new writer. Our implementation of such environment is to be found in \ttt{aliasenv\_cf.h}.
\item Other generic procedures, such as buffers, may be implemented either externally in the C preprocessor or by means of alias environments. Either implementation is then interfaced via records in an instruction table. We employ the latter way due to stubborn recursion-rejectiveness of the C preprocessor\footnote{Recursion may actually be achieved by means of various workarounds. Unfortunately, the implemented algorithms tend to fail for obscure reasons.}. Specifically, we implement an in-register SSE buffer in the `cf\_macros' environment (\ttt{aliasenv\_cfmacros.h}).
\end{itemize}
