\documentclass[final,hyperref={pdfpagelabels=false}]{beamer}
\usepackage{grffile}
\mode<presentation>{\usetheme{ECOMP}}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm, amssymb, latexsym}
%\usepackage{times}\usefonttheme{professionalfonts}  % obsolete
%\usefonttheme[onlymath]{serif}
\boldmath
%\usepackage[orientation=portrait,size=a0,scale=1.4,debug]{beamerposter}
\usepackage[orientation=portrait,size=a0,scale=1,debug]{beamerposter}
% change list indention level
% \setdefaultleftmargin{3em}{}{}{}{}{}
\setlength{\emergencystretch}{100pt}

\usepackage{longtable}

\usepackage{sidecap}
\usepackage{tikz}
\usepackage{placeins}
%\usepackage{animate}
\usepackage{float}
\usetikzlibrary{shapes,snakes,arrows,chains}
\usetikzlibrary{arrows.meta}
\usepackage{amsmath}
\usepackage{rotating}
\usepackage{caption}

\usepackage{ragged2e}

\tikzstyle{dashed}=                  [dash pattern=on 3mm off 3mm]

\newcommand{\msp}{\vspace{1cm}}
\newcommand{\cwdf}{.95\textwidth}
\newcommand{\cwdh}{.45\textwidth}

%\usepackage{snapshot} % will write a .dep file with all dependencies, allows for easy bundling

\usepackage{array,booktabs,tabularx}
\newcolumntype{Z}{>{\centering\arraybackslash}X} % centered tabularx columns
\newcommand{\pphantom}{\textcolor{ta3aluminium}} % phantom introduces a vertical space in p formatted table columns??!!

\listfiles

\title{SIMD code generator}
\author{Karel Tuček}
%\institute{; Charles University in Prague - Faculty of Mathematics and Physics}
\institute{\ ;}
\date{\today}

\begin{document}%Inicia o documento
\begin{frame}[fragile]
  \vspace{-0.5cm}
  \begin{columns}[T]%Inicia as Colunas
    \begin{column}{\cwdh}
%      \begin{beamercolorbox}{postercolumn}
      \msp
        \begin{block}{Introduction}
          \justify
              The center of our interest is a problem of pipelined realisation of a special case of data processing networks. These realisations are supposed to realise computations on series of independent data sets while utilizing SIMD instructions. We also theoretically investigate the possibilities and the problems of employment of control flow in these networks and also to implement a general framework suitable for generation of these realisations. In other words, our aim was the design of a framework which could act as a back-end part of a (trans) compiler. For the purpose of implementation, we targeted transformation of graph-described computations into vectorised C code.
        \end{block}

        \msp

        \begin{block}{Integration}
          \justify
            In yet other words, our generator is a program, which may be invoked from command line or from another programming environment. It takes graph description of a computation and a description of an instruction table and produces a C file which contains a module realising the computation.

            \ 

          \begin{figure}
            \input{figures2/exint}
          \end{figure}
             
        \end{block}


            \msp
%      \end{beamercolorbox}
    \end{column}

    \begin{column}{\cwdh}
%      \begin{beamercolorbox}{postercolumn}
      \msp
            \begin{block}{Processing of basic blocks}
              \justify
              Our idea is that SIMD parallelism should take place on the same instruction realised across multiple data sets. This way, vectorised C code may be easily generated via a topological search of the graph. During this search, instructions are fused across multiple data sets. Sometimes, the representation of data has to be transformed in order to fit its source and destination instruction. We add shortest conversion paths implicitly during the search.
            \end{block}


      \msp

            \begin{block}{Processing of control flow}
              \justify
              If the input graph contains any control flow constructs, we factorise the network with respect to these and connect the resulting components via register-mapped buffers. In other words, we cut the graph into partitions which represent basic blocks without any control flow. Then, we generate a code fragment which crawls over the network and pushes data through, using code fragments generated by the approach presented above. This is necessary, because we represent control flow by means of stream split and merge instructions which fully split data into independent streams.
            \end{block}

      \msp

            \begin{block}{Problems of control flow}
              \justify
               This approach presents multiple problems encompassing the question of data ordering and also of buffer sizes, since situations arise that different elements of the same data set have to wait for each other somewhere. We have to ensure that the data fit into the constant sized buffers, that the pipeline does not stall (due to overfilled or underfilled buffers) and that (ideally) all data get processed by vectorised instructions.
            \end{block}

            \msp

    \end{column}
  \end{columns}
  \vskip2ex

  \begin{columns}[T]
    \begin{column}{\cwdf}
%      \begin{beamercolorbox}{postercolumn}

            \begin{block}{Example - instruction table - pseudo SIMD set }
              \input{exinstab}
            \end{block}
      \msp


            \begin{block}{Example - generation of basic blocks}
              \input{exbb}
            \end{block}
      \msp

        \begin{block}{Example - control flow preprocessing transformations}
          \input{expar}
        \end{block}
      \msp

%      \end{beamercolorbox}
    \end{column}
  \end{columns}


  \begin{columns}[T]
    \begin{column}{\cwdh}
%      \begin{beamercolorbox}{postercolumn}

          \begin{block}{Example - graph representation of control flow}
            \input{excf}
          \end{block}

%      \end{beamercolorbox}
    \end{column}
    \begin{column}{\cwdh}
%      \begin{beamercolorbox}{postercolumn}


            \begin{block}{Architecture of our solution}
              \justify
              Our implementation is designed to be easily extensible. Namely, it is general with respect to the target language, runtime environment and SIMD extension. For this reason we have decided to design it as a highly sophisticated text processor. Input consists of a file describing the computation and of a file containing an instruction table. Instruction table describes semantics of instruction identifiers and also provides instruction patterns. These patterns are written in a special notation which resembles the system of shell expansion. Our implementation handles graphs without control flow and networks which contain branching. We provide a fully tested instruction table of C operators, implemented via Intel's SSE extension. 
            \end{block}
      \msp

          \begin{block}{Other information}
            \begin{itemize}
              \item Bachelor Thesis: SIMD Code Generator
              \item Year: 2016
              \item Author: Karel Tuček, kareltucek at centrum.cz
              \item Supervisor: RNDr. David Bednárek, Ph.D., bednarek at ksi.mff.cuni.cz
              \item Insitution: Charles University in Prague, Faculty of Mathematics and Physics, Department of Software Engineering
            \end{itemize}
          \end{block}



%      \end{beamercolorbox}
    \end{column}
  \end{columns}


\end{frame}
\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
