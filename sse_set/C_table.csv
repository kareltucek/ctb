logical	instruction	bool	AND.bool		1	1	$$arg1 && $$arg2		C	10
logical	instruction	bool	EQ.bool		1	1	$$arg1 == $$arg2		C	10
logical	instruction	bool	NE.bool		1	1	$$arg1 != $$arg2		C	10
logical	instruction	bool	NOT.bool		1	1	! $$arg1        		C	10
logical	instruction	bool	OR.bool		1	1	$$arg1 || $$arg 		C	10
logical	instruction	bool	XOR.bool		1	1	$$arg1 ^ $$arg2 		C	10
relational	instruction	bool	EQ.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 == $$arg2		C	10
relational	instruction	bool	GE.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 >= $$arg2		C	10
relational	instruction	bool	GT.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 > $$arg2		              C	10
relational	instruction	bool	LE.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 <= $$arg2		C	10
relational	instruction	bool	LT.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 < $$arg2		C	10
relational	instruction	bool	NE.${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}		1	1	$$arg1 != $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	ADD.$num		1	1	$$arg1 + $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	DIV.$num		1	1	$$arg1 / $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	MOD.$num		1	1	$$arg1 % $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	MUL.$num		1	1	$$arg1 * $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	SUB.$num		1	1	$$arg1 - $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	XOR.$num		1	1	$$arg1 ^ $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	NOT.$num		1	1	~ $$arg1       		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	LSF.$num		1	1	$$arg1 << $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	AND.$num		1	1	$$arg1 & $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	OR.$num		1	1	$$arg1 | $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	RSF.$num		1	1	$$arg1 >> $$arg2		C	10
conversions	instruction	${t->double,float,bool,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	CVRT.${u->double,float,bool,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}.$t		1	1	($t)$$arg1		C	10
IO	instruction	${t->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t,bool}	LD.$t	input	1	1	$$input		C	10
IO	instruction	${t->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t,bool}	ST.$t	output	1	1	$$output = $$arg1		C	10
types	type_version	bool	1	bool						
types	type_version	double	1	double						
types	type_version	float	1	float						
types	type_version	int16_t	1	int16_t						
types	type_version	int32_t	1	int32_t						
types	type_version	int64_t	1	int64_t						
types	type_version	int8_t	1	int8_t						
types	type_version	uint16_t	1	uint16_t						
types	type_version	uint32_t	1	uint32_t						
types	type_version	uint64_t	1	uint64_t						
types	type_version	uint8_t	1	uint8_t						
sse_types	type_version	${type -> int,uint}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	$n	__m128i						
sse_types	type_version	float	$[128/32/${w->2,1}]	__m128d						
sse_types	type_version	double	$[128/64/${w->1}]	__m128d						
sse_types	type_version	bool	${ w->2,4,8,16,32}	uint						
sse_types	type_version	bool	${ w->64,128}	__m128i						
sse_logical	instruction	bool	${name,op->AND,&,OR,|,XOR,^}.bool		${w->1,2,4,8,16,32}	$w	$$arg1 $op $$arg2		C	5
sse_logical	instruction	bool	NOT.bool		${w->1,2,4,8,16,32}	$w	~$$arg1 		C	5
sse_logical	instruction	bool	EQ.bool		${w->1,2,4,8,16,32}	$w	~($$arg1 ^ $$arg2)		C	5
sse_logical	instruction	bool	NE.bool		${w->1,2,4,8,16,32}	$w	$$arg1 ^ $$arg2		C	5
sse_logical	instruction	bool	GT.bool		${w->1,2,4,8,16,32}	$w	$$arg1 & (~$$arg2)		C	5
sse_logical	instruction	bool	LT.bool		${w->1,2,4,8,16,32}	$w	(~$$arg1) & $$arg2		C	5
sse_logical	instruction	bool	GE.bool		${w->1,2,4,8,16,32}	$w	$$arg1 | (~($$arg1 ^ $$arg2))		C	5
sse_logical	instruction	bool	LE.bool		${w->1,2,4,8,16,32}	$w	$$arg2 | (~($$arg1 ^ $$arg2))		C	5
sse_logical	instruction	bool	${name,op->AND,and,OR,or,XOR,xor}.bool		${w->64,128}	$w	_mm_$op_si128($$arg1,$$arg2)		sse	5
sse_logical	instruction	bool	NOT.bool		${w->64,128}	$w	_mm_sub_epi32(_mm_set1_epi32(0),$$arg1)		sse	5
sse_logical	instruction	bool	EQ.bool		${w->64,128}	$w	_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2))		sse	5
sse_logical	instruction	bool	NE.bool		${w->64,128}	$w	_mm_xor_si128($$arg1,$$arg2)		sse	5
sse_logical	instruction	bool	GT.bool		${w->64,128}	$w	_mm_and_si128($$arg1,_mm_sub_epi32(_mm_set1_epi32(0),$$arg2))		sse	5
sse_logical	instruction	bool	LT.bool		${w->64,128}	$w	_mm_and_si128($$arg2,_mm_sub_epi32(_mm_set1_epi32(0),$$arg1))		sse	5
sse_logical	instruction	bool	GE.bool		${w->64,128}	$w	_mm_or_si128($$arg1,_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2)))		sse	5
sse_logical	instruction	bool	LE.bool		${w->64,128}	$w	_mm_or_si128($$arg2,_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2)))		sse	5
sse_relational	instruction	bool	${name,op->EQ,eq,GT,gt,LT,lt}.${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t		$n	$n	_mm_cmp$op_$c$w($$arg1,$$arg2)		$tag	10
sse_relational	instruction	bool	NE.${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t		$n	$n	_mm_sub_epi32(_mm_set1_epi32(0),_mm_cmpeq_$c$w($$arg1,$$arg2))		$tag	10
sse_relational	instruction	bool	${name,op->GE,gt,LE,lt}.${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t		$n	$n	_mm_or_si128(_mm_cmpeq_$c$w($$arg1,$$arg2),_mm_cmp$op_$c$w($$arg1,$$arg2))		$tag	10
sse_relational	instruction	bool	${name,op->EQ,eq,GT,gt,LT,lt,LE,le,GE,ge,NE,neq}.${t,c,n->double,pd,2,float,ps,4,float,ps,2}		$n	$n	_mm_cmp$op_$c($$arg1,$$arg2)		sse	10
sse_arithetic_std	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	${name,op->ADD,add,SUB,sub}.$t$w_t		$n	$n	_mm_$op_$c$w($$arg1,$$arg2)		sse	10
sse_arithetic_std	instruction	${t,c,tag->uint,epu,sse,int,epi,sse4.1}${w,n->32,2,16,2,8,2}_t	${name,op->MUL,mul}.$t$w_t		$n	$n	_mm_$op_$c$w($$arg1,$$arg2)		$tag	10
sse_arithetic_std	instruction	${t,c,tag->int,epi,sse}${w,n->32,2,16,2,8,2}_t	${name,op->MUL,mul}.$t$w_t		$n	$n	_mm_shuffle_epi32(_mm_$op_$c$w($$arg1, $$arg2), _MM_SHUFFLE (0,0,2,0))		$tag	5
sse_arithetic_std	instruction	${t,c,n->float,ps,4,float,ps,2,double,pd,2}	${name,op->ADD,add,SUB,sub,MUL,mul,DIV,div}.$t$w_t		$n	$n	_mm_$op_$c($$arg1,$$arg2)		sse	10
sse_arithmetic_bin	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	${name,op->AND,and,OR,or,XOR,xor}.$t$w_t		$n	$n	_mm_$op_si128($$arg1,$$arg2)		sse	5
sse_arithmetic_bin	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	NOT.$t$w_t		$n	$n	_mm_sub_epi32(_mm_set1_epi32(0),$$arg1)		sse	5
sse_conversions	instruction	${t,c->int32_t,epi32,uint32_t,epi32}	CVRT.${u,d->double,pd}.$t		2	2	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->int32_t,epi32,uint32_t,epi32}	CVRT.${u,d->float,ps}.$t		${w->2,4}	$w	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->float,ps}	CVRT.${u,d->uint32_t,epi32,int32_t,epi32}.$t		${w->2,4}	$w	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->double,pd}	CVRT.${u,d->uint32_t,epi32,int32_t,epi32}.$t		2	2	_mm_cvt$d_$c($$arg1)		sse	10
sse_IO	instruction	${t->int,uint}${w,n->8,16,16,8,32,4,64,2}_t	LD.$t$2_t		$n	$n	_mm_loadu_si128((const __m128i*)&$$input)		sse	10
sse_IO	instruction	${t,n,c,l->float,4,ps,,double,2,pd,l}	LD.$t		$n	$n	_mm_loadu_$c((const __m128$l*)&$$input)		sse	10
sse_IO	instruction	${t->int,uint}${w,n->8,16,16,8,32,4,64,2}_t	ST.$t$2_t		$n	$n	_mm_storeu_si128((const __m128i*)&$$output,$$arg1)		sse	10
sse_IO	instruction	${t,n,c,l->float,4,ps,,double,2,pd,l}	ST.$t		$n	$n	_mm_storeu_$c((const __m128$l*)&$$output,$$arg1)		sse	10
#splits,glues...										
#boolean vector load										
