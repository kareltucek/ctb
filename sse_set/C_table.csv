logical	instruction	bool	bool,bool	AND.bool		1	1	$$arg1 && $$arg2		C	10
logical	instruction	bool	bool,bool	EQ.bool		1	1	$$arg1 == $$arg2		C	10
logical	instruction	bool	bool,bool	NE.bool		1	1	$$arg1 != $$arg2		C	10
logical	instruction	bool	bool	NOT.bool		1	1	! $$arg1        		C	10
logical	instruction	bool	bool,bool	OR.bool		1	1	$$arg1 || $$arg 		C	10
logical	instruction	bool	bool,bool	XOR.bool		1	1	$$arg1 ^ $$arg2 		C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	EQ.$num		1	1	$$arg1 == $$arg2		C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	GE.$num		1	1	$$arg1 >= $$arg2		C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	GT.$num		1	1	$$arg1 > $$arg2		              C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	LE.$num		1	1	$$arg1 <= $$arg2		C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	LT.$num		1	1	$$arg1 < $$arg2		C	10
relational	instruction	bool	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t},$num	NE.$num		1	1	$$arg1 != $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	ADD.$num		1	1	$$arg1 + $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	DIV.$num		1	1	$$arg1 / $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	MOD.$num		1	1	$$arg1 % $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	MUL.$num		1	1	$$arg1 * $$arg2		C	10
arithetic_std	instruction	${num->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	SUB.$num		1	1	$$arg1 - $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	XOR.$num		1	1	$$arg1 ^ $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num	NOT.$num		1	1	~ $$arg1       		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	LSF.$num		1	1	$$arg1 << $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	AND.$num		1	1	$$arg1 & $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	OR.$num		1	1	$$arg1 | $$arg2		C	10
arithmetic_bin	instruction	${num->int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	$num,$num	RSF.$num		1	1	$$arg1 >> $$arg2		C	10
conversions	instruction	${t->double,float,bool,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	${u->double,float,bool,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t}	CVRT.$u.$t		1	1	($t)$$arg1		C	10
IO	instruction	${t->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t,bool}		LD.$t	input	1	1	$$input		C	10
IO	instruction	${t->float,double,int8_t,int16_t,int32_t,int64_t,uint8_t,uint16_t,uint32_t,uint64_t,bool}	$t	ST.$t	output	1	1	$$output = $$arg1		C	10
types	type_version	bool	1	1	bool						
types	type_version	double	64	1	double						
types	type_version	float	32	1	float						
types	type_version	int16_t	16	1	int16_t						
types	type_version	int32_t	32	1	int32_t						
types	type_version	int64_t	64	1	int64_t						
types	type_version	int8_t	8	1	int8_t						
types	type_version	uint16_t	16	1	uint16_t						
types	type_version	uint32_t	32	1	uint32_t						
types	type_version	uint64_t	64	1	uint64_t						
types	type_version	uint8_t	8	1	uint8_t						
sse_types	type_version	${type -> int,uint}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	$w	$n	__m128i						
sse_types	type_version	float	32	$[128/32/${w->2,1}]	__m128d						
sse_types	type_version	double	64	$[128/64/${w->1}]	__m128d						
sse_types	type_version	bool	1	${ w->2,4,8,16,32}	uint						
sse_types	type_version	bool	1	${ w->64,128}	__m128i						
sse_logical	instruction	bool	bool,bool	${name,op->AND,&,OR,|,XOR,^}.bool		${w->1,2,4,8,16,32}	$w	$$arg1 $op $$arg2		C	5
sse_logical	instruction	bool	bool	NOT.bool		${w->1,2,4,8,16,32}	$w	~$$arg1 		C	5
sse_logical	instruction	bool	bool,bool	EQ.bool		${w->1,2,4,8,16,32}	$w	~($$arg1 ^ $$arg2)		C	5
sse_logical	instruction	bool	bool,bool	NE.bool		${w->1,2,4,8,16,32}	$w	$$arg1 ^ $$arg2		C	5
sse_logical	instruction	bool	bool,bool	GT.bool		${w->1,2,4,8,16,32}	$w	$$arg1 & (~$$arg2)		C	5
sse_logical	instruction	bool	bool,bool	LT.bool		${w->1,2,4,8,16,32}	$w	(~$$arg1) & $$arg2		C	5
sse_logical	instruction	bool	bool,bool	GE.bool		${w->1,2,4,8,16,32}	$w	$$arg1 | (~($$arg1 ^ $$arg2))		C	5
sse_logical	instruction	bool	bool,bool	LE.bool		${w->1,2,4,8,16,32}	$w	$$arg2 | (~($$arg1 ^ $$arg2))		C	5
sse_logical	instruction	bool	bool,bool	${name,op->AND,and,OR,or,XOR,xor}.bool		${w->64,128}	$w	_mm_$op_si128($$arg1,$$arg2)		sse	5
sse_logical	instruction	bool	bool	NOT.bool		${w->64,128}	$w	_mm_sub_epi32(_mm_set1_epi32(0),$$arg1)		sse	5
sse_logical	instruction	bool	bool,bool	EQ.bool		${w->64,128}	$w	_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2))		sse	5
sse_logical	instruction	bool	bool,bool	NE.bool		${w->64,128}	$w	_mm_xor_si128($$arg1,$$arg2)		sse	5
sse_logical	instruction	bool	bool,bool	GT.bool		${w->64,128}	$w	_mm_and_si128($$arg1,_mm_sub_epi32(_mm_set1_epi32(0),$$arg2))		sse	5
sse_logical	instruction	bool	bool,bool	LT.bool		${w->64,128}	$w	_mm_and_si128($$arg2,_mm_sub_epi32(_mm_set1_epi32(0),$$arg1))		sse	5
sse_logical	instruction	bool	bool,bool	GE.bool		${w->64,128}	$w	_mm_or_si128($$arg1,_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2)))		sse	5
sse_logical	instruction	bool	bool,bool	LE.bool		${w->64,128}	$w	_mm_or_si128($$arg2,_mm_sub_epi32(_mm_set1_epi32(0),_mm_xor_si128($$arg1,$$arg2)))		sse	5
sse_relational	instruction	bool	${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t,$t$w_t	${name,op->EQ,eq,GT,gt,LT,lt}.$t$w_t		$n	$n	_mm_cmp$op_$c$w($$arg1,$$arg2)		$tag	10
sse_relational	instruction	bool	${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t,$t$w_t	NE.$t$w_t		$n	$n	_mm_sub_epi32(_mm_set1_epi32(0),_mm_cmpeq_$c$w($$arg1,$$arg2))		$tag	10
sse_relational	instruction	bool	${t,c->int,epi,uint,epi}${w,n,tag->64,2,sse4.1,32,4,sse,32,2,sse,16,8,sse,16,4,sse,16,2,sse,8,16,sse,8,8,sse,8,4,sse,8,2,sse}_t,$t$w_t	${name,op->GE,gt,LE,lt}.$t$w_t		$n	$n	_mm_or_si128(_mm_cmpeq_$c$w($$arg1,$$arg2),_mm_cmp$op_$c$w($$arg1,$$arg2))		$tag	10
sse_relational	instruction	bool	${t,c,n->double,pd,2,float,ps,4,float,ps,2},$t	${name,op->EQ,eq,GT,gt,LT,lt,LE,le,GE,ge,NE,neq}.$t		$n	$n	_mm_cmp$op_$c($$arg1,$$arg2)		sse	10
sse_arithetic_std	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	$t$w_t,$t$w_t	${name,op->ADD,add,SUB,sub}.$t$w_t		$n	$n	_mm_$op_$c$w($$arg1,$$arg2)		sse	10
sse_arithetic_std	instruction	${t,c,tag->uint,epu,sse,int,epi,sse4.1}${w,n->32,2,16,2,8,2}_t	$t$w_t,$t$w_t	${name,op->MUL,mul}.$t$w_t		$n	$n	_mm_$op_$c$w($$arg1,$$arg2)		$tag	10
sse_arithetic_std	instruction	${t,c,tag->int,epi,sse}${w,n->32,2,16,2,8,2}_t	$t$w_t,$t$w_t	${name,op->MUL,mul}.$t$w_t		$n	$n	_mm_shuffle_epi32(_mm_$op_$c$w($$arg1, $$arg2), _MM_SHUFFLE (0,0,2,0))		$tag	5
sse_arithetic_std	instruction	${t,c,n->float,ps,4,float,ps,2,double,pd,2}	$t,$t	${name,op->ADD,add,SUB,sub,MUL,mul,DIV,div}.$t$w_t		$n	$n	_mm_$op_$c($$arg1,$$arg2)		sse	10
sse_arithmetic_bin	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	$t$w_t,$t$w_t	${name,op->AND,and,OR,or,XOR,xor}.$t$w_t		$n	$n	_mm_$op_si128($$arg1,$$arg2)		sse	5
sse_arithmetic_bin	instruction	${t,c->int,epi,uint,epi}${w,n->64,2,32,4,32,2,16,8,16,4,16,2,8,16,8,8,8,4,8,2}_t	$t$w_t,$t$w_t	NOT.$t$w_t		$n	$n	_mm_sub_epi32(_mm_set1_epi32(0),$$arg1)		sse	5
sse_conversions	instruction	${t,c->int32_t,epi32,uint32_t,epi32}	${u,d->double,pd}	CVRT.$u.$t		2	2	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->int32_t,epi32,uint32_t,epi32}	${u,d->float,ps}	CVRT.$u.$t		${w->2,4}	$w	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->float,ps}	${u,d->uint32_t,epi32,int32_t,epi32}	CVRT.$u.$t		${w->2,4}	$w	_mm_cvt$d_$c($$arg1)		sse	10
sse_conversions	instruction	${t,c->double,pd}	${u,d->uint32_t,epi32,int32_t,epi32}	CVRT.$u.$t		2	2	_mm_cvt$d_$c($$arg1)		sse	10
sse_IO	instruction	${t->int,uint}${w,n->8,16,16,8,32,4,64,2}_t		LD.$t$w_t		$n	$n	_mm_loadu_si128((const __m128i*)&$$input)		sse	10
sse_IO	instruction	${t,n,c,l->float,4,ps,,double,2,pd,l}		LD.$t		$n	$n	_mm_loadu_$c((const __m128$l*)&$$input)		sse	10
sse_IO	instruction	${t->int,uint}${w,n->8,16,16,8,32,4,64,2}_t	$t$w_t	ST.$t$w_t		$n	$n	_mm_storeu_si128((const __m128i*)&$$output,$$arg1)		sse	10
sse_IO	instruction	${t,n,c,l->float,4,ps,,double,2,pd,l}	$t	ST.$t		$n	$n	_mm_storeu_$c((const __m128$l*)&$$output,$$arg1)		sse	10
#splits,glues...										
#boolean vector load										
