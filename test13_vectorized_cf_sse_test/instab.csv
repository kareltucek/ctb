#note	type	output type	input types	op id	flags	width in	width out	code	tags	rating	code custom	
	instruction	int32_t	int32_t,int32_t	ADDI		1	1	$$arg1 + $$arg2		0		
	instruction	bool	int32_t	ZERO		1	1	$$arg1 == 0		0		
	instruction	int32_t	int32_t,int32_t	MULI		1	1	$$arg1 * $$arg2		0		
	instruction	int32_t	int32_t	INC		1	1	$$arg1++		0		
	instruction	int32_t	int32_t	MOD4		1	1	$$arg1 % 4		0		
	instruction	int32_t		LDI	input	1	1	i_$$ioindex++		0	global:  int i_$$ioindex = 0;	
	instruction	int32_t	int32_t	STI	output	1	1	printf("OUTPUT %i\n", $$arg1)		0		
	instruction	bool		LDB	input	1	1	(i_$ioindex++ % 3) == 0		0	global:  int i_$$ioindex = 0;	

#${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\

split st	instruction		bool,\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
	SPLIT_ST_$type	output	1	1			0\
	labels:  SPLIT_ST_$$ioindex: \
	labelsr: REQ_SPLIT_ST_$$ioindex: \
	gonextone: if($$$$$$$${BUFFER_FULL(L_$$ioindex)}) goto REQ_SPLIT_LDL_$$ioindex; if($$$$$$$${BUFFER_FULL(R_$$ioindex)}) goto REQ_SPLIT_LDR_$$ioindex;\
	gonext:    if($$$$$$$${BUFFER_FULL_GRANULAR(L_$$ioindex)}) goto SPLIT_LDL_$$ioindex; if($$$$$$$${BUFFER_FULL_GRANULAR(R_$$ioindex)}) goto SPLIT_LDR_$$ioindex;\
	default: if($$arg1){ $$$$$$$${BUFFER_PUSH_ONE($$buffersize,$width,L_$$ioindex,$abbrev,$$arg2)}; } else { $$$$$$$${BUFFER_PUSH_ONE($$buffersize,$width,R_$$ioindex,$abbrev,$$arg2)}; };

split load	instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		SPLIT_LD${side->L,R}_$type	input	1	1			0\
	labels:  SPLIT_LD$side_$$ioindex: \
	labelsr: REQ_SPLIT_LD$side_$$ioindex: \
	global:  $$$$$$$${BUFFER_DECL($$buffersize,$width,$$granularity,$$granularity,$side_$$ioindex,$dtype)};\
	logs:    $$$$$$$${BUFFER_DUMP_VECTOR($$buffersize,$width,$side_$$ioindex)};\
	goprevone: if($$$$$$$${BUFFER_EMPTY($side_$$ioindex)}) goto REQ_SPLIT_ST_$$ioindex;\
	goprev:    if($$$$$$$${BUFFER_EMPTY_GRANULAR($side_$$ioindex)}) goto REQ_SPLIT_ST_$$ioindex;\
	emptygran:    $$$$$$$${BUFFER_EMPTY_GRANULAR($side_$$ioindex)} || \
	emptyind:     $$$$$$$${BUFFER_EMPTY($side_$$ioindex)} || \
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_ONE($$buffersize,$width,$side_$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_ONE($side_$$ioindex)};
    
split load	instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		SPLIT_LD${side->L,R}_$type	input	$width	$width			0\
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_VECTOR($$buffersize,$width,$side_$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_VECTOR($side_$$ioindex)};


merge st	instruction		\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
	MERGE_ST${side->L,R}_$type	output	1	1			0\
	labels:  MERGE_ST$side_$$ioindex: \
	labelsr: REQ_MERGE_ST$side_$$ioindex: \
	global:  $$$$$$$${BUFFER_DECL($$buffersize,$width,$$granularity,$$granularity,$side_$$ioindex,$dtype)};\
	logs:    $$$$$$$${BUFFER_DUMP_VECTOR($$buffersize,$width,$side_$$ioindex)};\
	gonextone: if($$$$$$$${BUFFER_FULL($side_$$ioindex)}) goto REQ_MERGE_$$ioindex;\
	gonext:    if($$$$$$$${BUFFER_FULL_GRANULAR($side_$$ioindex)}) goto MERGE_$$ioindex;\
	fullgran:     $$$$$$$${BUFFER_FULL_GRANULAR($side_$$ioindex)} || \
	default: $$$$$$$${BUFFER_PUSH_ONE($$buffersize,$width,$side_$$ioindex,$abbrev,$$arg1)};

merge process	instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		MERGE_PROC_$type	input	1	1			0\
	labels:  MERGE_$$ioindex: BUFF_LD_$$ioindex:\
	labelsr: REQ_MERGE_$$ioindex: REQ_BUFF_LD_$$ioindex:\
	global:  $$$$$$$${BUFFER_DECL($$buffersize,$width,$$granularity,$$granularity,M_$$ioindex,$dtype)};\
	logs:    $$$$$$$${BUFFER_DUMP_VECTOR($$buffersize,$width,M_$$ioindex)};\
	indic:   merge_part\
	gonextone: if($$$$$$$${BUFFER_FULL(M_$$ioindex)}) goto REQ_MERGE_LD_$$ioindex;\
	gonext:    if($$$$$$$${BUFFER_FULL_GRANULAR(M_$$ioindex)}) goto MERGE_LD_$$ioindex;\
	fullgran:     $$$$$$$${BUFFER_FULL_GRANULAR(M_$$ioindex)} || \
	goprevone: if($$$$$$$${BUFFER_EMPTY($$ioindex)}) goto REQ_BUFF_ST_$$ioindex;\
	goprev:    if($$$$$$$${BUFFER_EMPTY_GRANULAR($$ioindex)}) goto REQ_BUFF_ST_$$ioindex;\
	emptygran:    $$$$$$$${BUFFER_EMPTY_GRANULAR($$ioindex)} || \
	emptyind:     $$$$$$$${BUFFER_EMPTY($$ioindex)} || \
	defaultsingle: \
bool tmp; $$$$$$$${BUFFER_PEEK_ONE(16,16,$$ioindex,epi8,tmp)}; \
$$type myval;\
if(tmp)\
{\
  if($$$$$$$${BUFFER_EMPTY(L_$$ioindex)})\
    goto REQ_MERGE_STL_$$ioindex;\
  $$$$$$$${BUFFER_PEEK_ONE($$buffersize,$width,L_$$ioindex,$abbrev,myval)}; $$$$$$$${BUFFER_CONSUME_ONE(L_$$ioindex)};\
}\
else\
{\
  if($$$$$$$${BUFFER_EMPTY(R_$$ioindex)})\
    goto REQ_MERGE_STR_$$ioindex;\
  $$$$$$$${BUFFER_PEEK_ONE($$buffersize,$width,R_$$ioindex,$abbrev,myval)}; $$$$$$$${BUFFER_CONSUME_ONE(R_$$ioindex)};\
}\
$$$$$$$${BUFFER_CONSUME_ONE($$ioindex)};\
$$$$$$$${BUFFER_PUSH_ONE($$buffersize,$width,M_$$ioindex,$abbrev,myval)};

merge load	instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		MERGE_LD_$type	input	1	1			0\
	labels:  MERGE_LD_$$ioindex: \
	labelsr: REQ_MERGE_LD_$$ioindex: \
	goprevone: if($$$$$$$${BUFFER_EMPTY(M_$$ioindex)}) goto REQ_MERGE_$$ioindex;\
	goprev:    if($$$$$$$${BUFFER_EMPTY_GRANULAR(M_$$ioindex)}) goto REQ_MERGE_$$ioindex;\
	emptygran:    $$$$$$$${BUFFER_EMPTY_GRANULAR(M_$$ioindex)} || \
	emptyind:     $$$$$$$${BUFFER_EMPTY(M_$$ioindex)} || \
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_ONE($$buffersize,$width,M_$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_ONE(M_$$ioindex)};

merge load	instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		MERGE_LD_$type	input	$width	$width			0\
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_VECTOR($$buffersize,$width,M_$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_VECTOR(M_$$ioindex)};

buffer st	instruction		\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
	BUFF_ST_$type	output	1	1			0\
	labels:  BUFF_ST_$$ioindex: \
	labelsr: REQ_BUFF_ST_$$ioindex: \
	global:  $$$$$$$${BUFFER_DECL($$buffersize,$width,$$granularity,$$granularity,$$ioindex,$dtype)};\
	logs:    $$$$$$$${BUFFER_DUMP_VECTOR($$buffersize,$width,$$ioindex)};\
	gonextone: if($$$$$$$${BUFFER_FULL($$ioindex)}) goto REQ_BUFF_LD_$$ioindex;\
	gonext:    if($$$$$$$${BUFFER_FULL_GRANULAR($$ioindex)}) goto BUFF_LD_$$ioindex;\
	fullgran:     $$$$$$$${BUFFER_FULL_GRANULAR($$ioindex)} || \
	default: $$$$$$$${BUFFER_PUSH_ONE($$buffersize,$width,$$ioindex,$abbrev,$$arg1)};

buffer ld	 instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		BUFF_LD_$type	input	1	1			0\
	labels:  BUFF_LD_$$ioindex:\
	labelsr: REQ_BUFF_LD_$$ioindex:\
	goprevone: if($$$$$$$${BUFFER_EMPTY($$ioindex)}) goto REQ_BUFF_ST_$$ioindex;\
	goprev:    if($$$$$$$${BUFFER_EMPTY_GRANULAR($$ioindex)}) goto REQ_BUFF_ST_$$ioindex;\
	emptygran:    $$$$$$$${BUFFER_EMPTY_GRANULAR($$ioindex)} || \
	emptyind:   $$$$$$$${BUFFER_EMPTY($$ioindex)} ||\
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_ONE($$buffersize,$width,$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_ONE($$ioindex)};

buffer ld	 instruction	\
${type,width,dtype,abbrev->bool,16,__m128i,epi8,ssebool,16,__m128i,epi16,double,2,__m128d,ps,float,4,__m128,pd,int16_t,8,__m128i,epi16,int32_t,4,__m128i,epi32,int64_t,2,__m128i,epi64,int8_t,16,__m128i,epi8,uint16_t,8,__m128i,epi16,uint32_t,4,__m128i,epi32,uint64_t,2,__m128i,epi64,uint8_t,16,__m128i,epi8}\
		BUFF_LD_$type	input	$width	$width			0\
	default: $$type $$name; $$$$$$$${BUFFER_PEEK_VECTOR($$buffersize,$width,$$ioindex,$abbrev,$$name)}; $$$$$$$${BUFFER_CONSUME_VECTOR($$ioindex)};

#note	type	output type	input types	op id	flags	name	transformer	args
split	expansion	int32_t,int32_t	bool,int32_t	SPLIT_int32_t		split	cf	SPLIT_ST_int32_t,SPLIT_LDL_int32_t,SPLIT_LDR_int32_t
split	expansion	int32_t	bool,int32_t,int32_t	MERGE_int32_t		merge	cf	MERGE_LD_int32_t,MERGE_PROC_int32_t,MERGE_STL_int32_t,MERGE_STR_int32_t,BUFF_ST_bool
split	expansion	${type->int32_t,bool}	$type	BUFF_$type		buffer	cf	BUFF_ST_$type, BUFF_LD_$type

#note	type	type id	bitwidth	width	code
	type_version	FLOAT	32	1	float
	type_version	int32_t	32	1	int
	type_version	bool	8	1	bool
#note	type	type id	bitwidth	width in	width out	code1	code2	code custom	code generic	tags	rating
#j	type_conversion	FLOAT	32	2	4	_mm_movelh_ps($$arg1, $$arg2)					0
#j	type_conversion	int32_t	32	2	4	_mm_unpacklo_epi32($$arg1,$$arg2)					0
#j	type_conversion	int32_t	32	4	2	$$arg1	_mm_srli_si128($$arg1,4)				0

