!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	Development	//
$1_box	templates/bobox_box.h	/^  $1_box(const bobox::box_parameters_pack &box_params) : bobox::basic_box(box_params) {}$/;"	f	class:$1_box	access:public	signature:(const bobox::box_parameters_pack &box_params)
$1_box	templates/bobox_box.h	/^class $1_box : public bobox::basic_box {$/;"	c	inherits:bobox::basic_box
$1_box::$1_box	templates/bobox_box.h	/^  $1_box(const bobox::box_parameters_pack &box_params) : bobox::basic_box(box_params) {}$/;"	f	class:$1_box	access:public	signature:(const bobox::box_parameters_pack &box_params)
$1_box::BOBOX_BOX_INPUTS_LIST	templates/bobox_box.h	/^  BOBOX_BOX_INPUTS_LIST($2);$/;"	p	class:$1_box	access:public	signature:($2)
$1_box::BOBOX_BOX_OUTPUTS_LIST	templates/bobox_box.h	/^  BOBOX_BOX_OUTPUTS_LIST($3);$/;"	p	class:$1_box	access:public	signature:($3)
$1_box::model	templates/bobox_box.h	/^  typedef generic_model<$1_box> model;$/;"	t	class:$1_box	access:public
$name	xml2/instab.xml	/^<code_custom>$type $name = $arg1 + $arg2;<\/code_custom>$/;"	v
$name2	xml2/instab.xml	/^<code_custom>$type $name1 = (__m128i)_mm_movelh_ps((__m128)$arg1, (__m128)$arg1); $type $name2 = $arg1;<\/code_custom>$/;"	v
$output	xml2/instab.xml	/^<code>$output = $arg1<\/code>$/;"	v
ADD	model.h	43;"	d
ADD	model_bobox.h	26;"	d
ADD	model_generator.h	33;"	d
ADD	model_simple.h	26;"	d
ARG	generator.h	124;"	d
BOBOX_BOX_INPUTS_LIST	templates/bobox_box.h	/^  BOBOX_BOX_INPUTS_LIST($2);$/;"	p	class:$1_box	access:public	signature:($2)
BOBOX_BOX_OUTPUTS_LIST	templates/bobox_box.h	/^  BOBOX_BOX_OUTPUTS_LIST($3);$/;"	p	class:$1_box	access:public	signature:($3)
CEST	journal	/^Sat May  2 11:42:39 CEST 2015$/;"	v
CSVLOADER_GUARD	csvloader.h	2;"	d
DATATYPES_GUARD	datatypes.h	2;"	d
GENERATOR_GUARD	generator.h	3;"	d
GRAPH_GUARD	graph.h	2;"	d
INSTRUCTION_GUARD	instructions.h	3;"	d
LANGUAGEEMPTY_GUARD	languages.h	2;"	d
MODEL_BOBOX_GUARD	model_bobox.h	3;"	d
MODEL_GENERATOR_GUARD	model_generator.h	3;"	d
MODEL_GUARD	model.h	3;"	d
MODEL_SIMPLE_GUARD	model_simple.h	3;"	d
WRITER_GUARD	writer.h	3;"	d
XMLCheckResult	xmlloader.h	6;"	d
XMLLOADER_GUARD	xmlloader.h	2;"	d
_mm_mul_epu32	xml2/instab.xml	/^<code>_mm_shuffle_epi32(_mm_mul_epu32($arg1, $arg2), _MM_SHUFFLE (0,0,2,0))<\/code>$/;"	p	file:	signature:($arg1, $arg2)
acces_map	generator.h	/^            acces_map_t acces_map;$/;"	m	class:ctb::generator::data_t	access:private
acces_map_t	generator.h	/^            typedef std::map<int, writer<model_generator> > acces_map_t;$/;"	t	class:ctb::generator::data_t	access:private
access	model.h	/^      static std::string& access(const std::string&);$/;"	p	class:ctb::model_maker	access:public	signature:(const std::string&)
access	model.h	/^  std::string& model_maker<T,L>::access(const std::string& str)$/;"	f	class:ctb::model_maker	signature:(const std::string& str)
add	writer.h	/^        void add(std::string&& str, bool terminal) ;$/;"	p	class:ctb::writer	access:private	signature:(std::string&& str, bool terminal)
add	writer.h	/^    void writer<M>::add(std::string&& str, bool terminal)$/;"	f	class:ctb::writer	signature:(std::string&& str, bool terminal)
addcode	instructions.h	/^            \/*IAPI*\/void addcode(int wi, int wo, const std::string& c);$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int wi, int wo, const std::string& c)
addcode	instructions.h	/^    void instruction_table<T>::operation::addcode(int wi, int wo, const std::string& c)$/;"	f	class:ctb::instruction_table::operation	signature:(int wi, int wo, const std::string& c)
addcode_conversion	instructions.h	/^          \/*IAPI*\/void addcode_conversion(int from, int to, const std::string& c1, const std::string& c2);$/;"	p	class:ctb::instruction_table::type	access:public	signature:(int from, int to, const std::string& c1, const std::string& c2)
addcode_conversion	instructions.h	/^    void instruction_table<T>::type::addcode_conversion(int in, int out, const std::string& c1,const std::string& c2)$/;"	f	class:ctb::instruction_table::type	signature:(int in, int out, const std::string& c1,const std::string& c2)
addcode_type	instructions.h	/^          \/*IAPI*\/void addcode_type(int w, const std::string& c) ;$/;"	p	class:ctb::instruction_table::type	access:public	signature:(int w, const std::string& c)
addcode_type	instructions.h	/^    void instruction_table<T>::type::addcode_type(int w, const std::string& c)$/;"	f	class:ctb::instruction_table::type	signature:(int w, const std::string& c)
addedge	generator.h	/^        void addedge(vid_t aid, vid_t bid, int b_argpos) ;$/;"	p	class:ctb::generator	access:public	signature:(vid_t aid, vid_t bid, int b_argpos)
addedge	generator.h	/^    void generator<T,IT>::addedge(vid_t aid, vid_t bid, int b_argpos)  $/;"	f	class:ctb::generator	signature:(vid_t aid, vid_t bid, int b_argpos)
addedge	graph.h	/^        void addedge(I aid, I bid, int b_argpos = -1) ;$/;"	p	class:ctb::graph_generic	access:public	signature:(I aid, I bid, int b_argpos = -1)
addedge	graph.h	/^    void graph_generic<T,I,directed,O...>::addedge(I aid, I bid, int b_argpos)  $/;"	f	class:ctb::graph_generic	signature:(I aid, I bid, int b_argpos)
addoperation	instructions.h	/^        \/*IAPI*\/ operation_t& addoperation(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f) ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)
addoperation	instructions.h	/^    typename instruction_table<T>::operation_t& instruction_table<T>::addoperation(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)$/;"	f	class:ctb::instruction_table	signature:(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)
addtype	instructions.h	/^        \/*IAPI*\/ type_t& addtype(typename T::tid_t t) ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::tid_t t)
addtype	instructions.h	/^    typename instruction_table<T>::type_t& instruction_table<T>::addtype(typename T::tid_t t)$/;"	f	class:ctb::instruction_table	signature:(typename T::tid_t t)
addvert	generator.h	/^        template <typename...L> void addvert(vid_t v, id_t op, L... p) ;$/;"	p	class:ctb::generator	access:public	signature:(vid_t v, id_t op, L... p)
addvert	generator.h	/^    template <typename...L> void generator<T,IT>::addvert(vid_t v, id_t op, L... p)  $/;"	f	class:ctb::generator	signature:(vid_t v, id_t op, L... p)
addvert	graph.h	/^        template <typename...L> void addvert(I v, bool in , bool out , L&&... p) ;$/;"	p	class:ctb::graph_generic	access:public	signature:(I v, bool in , bool out , L&&... p)
addvert	graph.h	/^    void graph_generic<T,I,directed,O...>::addvert(I v, bool bin, bool bout, L&&... p)  $/;"	f	class:ctb::graph_generic	signature:(I v, bool bin, bool bout, L&&... p)
alias	model.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_maker	access:public	signature:(const std::string& a)
alias	model.h	/^  std::string model_maker<T,L>::alias(const std::string& a)$/;"	f	class:ctb::model_maker	signature:(const std::string& a)
alias	model_bobox.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_bobox	access:public	signature:(const std::string& a)
alias	model_bobox.h	/^  std::string model_bobox::alias(const std::string& a)$/;"	f	class:ctb::model_bobox	signature:(const std::string& a)
alias	model_generator.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_generator	access:public	signature:(const std::string& a)
alias	model_generator.h	/^  std::string model_generator::alias(const std::string& a)$/;"	f	class:ctb::model_generator	signature:(const std::string& a)
alias	model_simple.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_simple	access:public	signature:(const std::string& a)
alias	model_simple.h	/^  std::string model_simple::alias(const std::string& a)$/;"	f	class:ctb::model_simple	signature:(const std::string& a)
aliases	model.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_maker	access:protected
aliases	model.h	/^  template <typename T, typename L> std::map<std::string, std::string> model_maker<T,L>::aliases;$/;"	m	class:ctb::model_maker
aliases	model_bobox.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_bobox	access:protected
aliases	model_bobox.h	/^  std::map<std::string, std::string> model_bobox::aliases;$/;"	m	class:ctb::model_bobox
aliases	model_generator.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_generator	access:protected
aliases	model_generator.h	/^  std::map<std::string, std::string> model_generator::aliases;$/;"	m	class:ctb::model_generator
aliases	model_simple.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_simple	access:protected
aliases	model_simple.h	/^  std::map<std::string, std::string> model_simple::aliases;$/;"	m	class:ctb::model_simple
aliastab_t	model.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_maker	access:protected
aliastab_t	model_bobox.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_bobox	access:protected
aliastab_t	model_generator.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_generator	access:protected
aliastab_t	model_simple.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_simple	access:protected
append	writer.h	/^        template <bool dolars = false, typename Types> writer<M>& append(Types str) ;$/;"	p	class:ctb::writer	access:public	signature:(Types str)
append	writer.h	/^    template <bool dolars , typename Types> writer<M>& writer<M>::append(Types str)$/;"	f	class:ctb::writer	signature:(Types str)
architecture	README.md	/^In order to change the output architecture, you are supposed to provide different instruction tables.$/;"	v
br_ct	datatypes.h	/^      template <typename U> struct br_ct  { typedef decltype(std::declval<T const>()[std::declval<U>()]) type; };$/;"	s	class:ctb::proxy_	access:private
br_t	datatypes.h	/^      template <typename U> struct br_t { typedef decltype(std::declval<T      >()[std::declval<U>()]) type; };$/;"	s	class:ctb::proxy_	access:private
cIn	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
cOpId	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
cOut	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
cOutType	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
cType	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
calculate_distances	graph.h	/^        void calculate_distances();$/;"	p	class:ctb::graph_generic	access:public	signature:()
calculate_distances	graph.h	/^    void graph_generic<T,I,directed,O...>::calculate_distances()  $/;"	f	class:ctb::graph_generic	signature:()
clear	instructions.h	/^        void clear() ; $/;"	p	class:ctb::instruction_table	access:public	signature:()
clear	instructions.h	/^    void instruction_table<T>::clear()  $/;"	f	class:ctb::instruction_table	signature:()
clear	model.h	/^      static void clear();$/;"	p	class:ctb::model_maker	access:public	signature:()
clear	model.h	/^  void model_maker<T,L>::clear()$/;"	f	class:ctb::model_maker	signature:()
clear	writer.h	/^        void clear() ;$/;"	p	class:ctb::writer	access:public	signature:()
clear	writer.h	/^    void writer<M>::clear()  $/;"	f	class:ctb::writer	signature:()
cmdline	ctb.h	/^        int cmdline( int count, char ** args);$/;"	p	class:ctb::ctb	access:public	signature:( int count, char ** args)
cmdline	ctb.h	/^    int ctb<T,IT>::cmdline(int count, char ** args)$/;"	f	class:ctb::ctb	signature:(int count, char ** args)
code	instructions.h	/^              std::string code;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
code	instructions.h	/^            const std::string code;$/;"	m	struct:ctb::instruction_table::type::type_version	access:public
code1	instructions.h	/^            const std::string code1;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
code2	instructions.h	/^            const std::string code2;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
col_in_$1	templates/bobox_decl_in.h	/^static const bobox::column_index_type col_in_$1( $1);$/;"	p	signature:( $1)
col_out_$1	templates/bobox_decl_out.h	/^static const bobox::column_index_type col_out_$1( $1);$/;"	p	signature:( $1)
cols	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	g	class:ctb::csv_loader	access:private
conversion	instructions.h	/^            conversion(int in, int out, const std::string& c1, const std::string& c2);$/;"	p	struct:ctb::instruction_table::type::conversion	access:public	signature:(int in, int out, const std::string& c1, const std::string& c2)
conversion	instructions.h	/^          struct conversion$/;"	s	class:ctb::instruction_table::type	access:public
conversion	instructions.h	/^    instruction_table<T>::type::conversion::conversion(int i, int o, const std::string& c1, const std::string& c2) : width_in(i), width_out(o), code1(c1), code2(c2)$/;"	f	class:ctb::instruction_table::type::conversion	signature:(int i, int o, const std::string& c1, const std::string& c2)
conversions	instructions.h	/^          \/*EAPI*\/proxy<std::vector<conversion>> conversions;$/;"	m	class:ctb::instruction_table::type	access:public
crawl	graph.h	/^            template <bool recurse = false, bool inverse = false> void crawl(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q = NULL);$/;"	p	class:ctb::graph_generic::node	access:public	signature:(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q = NULL)
crawl	graph.h	/^    void graph_generic<T,I,directed,O...>::node::crawl(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q)$/;"	f	class:ctb::graph_generic::node	signature:(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q)
crawl_topological	graph.h	/^            void crawl_topological(std::function<void(node*)> f);$/;"	p	class:ctb::graph_generic::node	access:public	signature:(std::function<void(node*)> f)
crawl_topological	graph.h	/^    void graph_generic<T,I,directed,O...>::node::crawl_topological(std::function<void(node*)> f)$/;"	f	class:ctb::graph_generic::node	signature:(std::function<void(node*)> f)
csv_loader	csvloader.h	/^    class csv_loader$/;"	c	namespace:ctb
csv_loader_tag	csvloader.h	/^        struct csv_loader_tag{};$/;"	s	class:ctb::csv_loader	access:private
csvloader_default	csvloader.h	/^  typedef csv_loader<traits, generator_default, instruction_table_default,'\\t'> csvloader_default;$/;"	t	namespace:ctb
ctb	csvloader.h	/^namespace ctb$/;"	n
ctb	ctb.h	/^    class ctb $/;"	c	namespace:ctb
ctb	ctb.h	/^namespace ctb$/;"	n
ctb	datatypes.h	/^namespace ctb$/;"	n
ctb	generator.h	/^namespace ctb$/;"	n
ctb	graph.h	/^namespace ctb$/;"	n
ctb	instructions.h	/^namespace ctb$/;"	n
ctb	languages.h	/^namespace ctb$/;"	n
ctb	model.h	/^namespace ctb$/;"	n
ctb	model_bobox.h	/^namespace ctb$/;"	n
ctb	model_generator.h	/^namespace ctb$/;"	n
ctb	model_simple.h	/^namespace ctb$/;"	n
ctb	writer.h	/^namespace ctb$/;"	n
ctb	xmlloader.h	/^namespace ctb$/;"	n
ctb::csv_loader	csvloader.h	/^    class csv_loader$/;"	c	namespace:ctb
ctb::csv_loader::cIn	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
ctb::csv_loader::cOpId	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
ctb::csv_loader::cOut	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
ctb::csv_loader::cOutType	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
ctb::csv_loader::cType	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	e	enum:ctb::csv_loader::cols
ctb::csv_loader::cols	csvloader.h	/^        enum cols { cType = 0, cIn = 1, cOut = 2, cOpId = 3, cOutType = 4,};$/;"	g	class:ctb::csv_loader	access:private
ctb::csv_loader::csv_loader_tag	csvloader.h	/^        struct csv_loader_tag{};$/;"	s	class:ctb::csv_loader	access:private
ctb::csv_loader::export_graph	csvloader.h	/^        static void export_graph(IT& instab, std::ostream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::ostream&)
ctb::csv_loader::export_instab	csvloader.h	/^        static void export_instab(IT& instab, std::ostream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::ostream&)
ctb::csv_loader::flags	csvloader.h	/^        static std::map<std::string, int> flags;$/;"	m	class:ctb::csv_loader	access:private
ctb::csv_loader::insert	csvloader.h	/^        static void insert(IT& instab, std::string line);$/;"	p	class:ctb::csv_loader	access:private	signature:(IT& instab, std::string line)
ctb::csv_loader::insert	csvloader.h	/^    void csv_loader<T,G,IT,D>::insert(IT& instab, std::string line)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::string line)
ctb::csv_loader::load_graph	csvloader.h	/^        static void load_graph(G& graph, std::istream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(G& graph, std::istream&)
ctb::csv_loader::load_graph	csvloader.h	/^    void csv_loader<T,G,IT,D>::load_graph(G& graph, std::istream&)$/;"	f	class:ctb::csv_loader	signature:(G& graph, std::istream&)
ctb::csv_loader::load_instab	csvloader.h	/^        static void load_instab(IT& instab, std::istream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::istream&)
ctb::csv_loader::load_instab	csvloader.h	/^    void csv_loader<T,G,IT,D>::load_instab(IT& instab, std::istream& s)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::istream& s)
ctb::csv_loader::model_pre	csvloader.h	/^        typedef model_maker<csv_loader_tag, language_empty> model_pre;$/;"	t	class:ctb::csv_loader	access:private
ctb::csv_loader::preprocessline	csvloader.h	/^        static std::vector<std::string> preprocessline(std::string line);$/;"	p	class:ctb::csv_loader	access:private	signature:(std::string line)
ctb::csv_loader::preprocessline	csvloader.h	/^    std::vector<std::string> csv_loader<T,G,IT,D>::preprocessline(std::string line)$/;"	f	class:ctb::csv_loader	signature:(std::string line)
ctb::csv_loader::preprocessor	csvloader.h	/^        typedef writer<model_pre> preprocessor;$/;"	t	class:ctb::csv_loader	access:private
ctb::csv_loader::process	csvloader.h	/^        static void process(IT& instab, std::istream& s);$/;"	p	class:ctb::csv_loader	access:private	signature:(IT& instab, std::istream& s)
ctb::csv_loader::process	csvloader.h	/^    void csv_loader<T,G,IT,D>::process(IT& instab, std::istream& s)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::istream& s)
ctb::csv_loader::self_test	csvloader.h	/^        static void self_test() ;$/;"	p	class:ctb::csv_loader	access:public	signature:()
ctb::csv_loader::self_test	csvloader.h	/^    void csv_loader<T,G,IT,D>::self_test()$/;"	f	class:ctb::csv_loader	signature:()
ctb::csv_loader::shake	csvloader.h	/^        template <typename I> static void shake(I itr, I itre, std::string line, std::vector<std::string>& output);$/;"	p	class:ctb::csv_loader	access:private	signature:(I itr, I itre, std::string line, std::vector<std::string>& output)
ctb::csv_loader::shake	csvloader.h	/^    void csv_loader<T,G,IT,D>::shake(I itr, I itre, std::string line, std::vector<std::string>& output)$/;"	f	class:ctb::csv_loader	signature:(I itr, I itre, std::string line, std::vector<std::string>& output)
ctb::csv_loader::split	csvloader.h	/^        static std::vector<std::string> split(std::string str, char d);$/;"	p	class:ctb::csv_loader	access:private	signature:(std::string str, char d)
ctb::csv_loader::split	csvloader.h	/^    std::vector<std::string> csv_loader<T,G,IT,D>::split(std::string str, char d)$/;"	f	class:ctb::csv_loader	signature:(std::string str, char d)
ctb::csvloader_default	csvloader.h	/^  typedef csv_loader<traits, generator_default, instruction_table_default,'\\t'> csvloader_default;$/;"	t	namespace:ctb
ctb::ctb	ctb.h	/^    class ctb $/;"	c	namespace:ctb
ctb::ctb::cmdline	ctb.h	/^        int cmdline( int count, char ** args);$/;"	p	class:ctb::ctb	access:public	signature:( int count, char ** args)
ctb::ctb::cmdline	ctb.h	/^    int ctb<T,IT>::cmdline(int count, char ** args)$/;"	f	class:ctb::ctb	signature:(int count, char ** args)
ctb::ctb::generator_t	ctb.h	/^        typedef generator<T,IT> generator_t;$/;"	t	class:ctb::ctb	access:private
ctb::ctb::get_inner_name	ctb.h	/^        std::string get_inner_name(std::string fname);$/;"	p	class:ctb::ctb	access:private	signature:(std::string fname)
ctb::ctb::get_inner_name	ctb.h	/^    std::string ctb<T,IT>::get_inner_name(std::string f)$/;"	f	class:ctb::ctb	signature:(std::string f)
ctb::ctb::help	ctb.h	/^        void help();$/;"	p	class:ctb::ctb	access:private	signature:()
ctb::ctb::help	ctb.h	/^    void ctb<T,IT>::help()$/;"	f	class:ctb::ctb	signature:()
ctb::ctb::instab	ctb.h	/^        IT instab;$/;"	m	class:ctb::ctb	access:private
ctb::ctb::load_instab	ctb.h	/^        template<template <typename Q, typename QQ, typename QQQ> class L, typename...P> void load_instab(P...params) ;$/;"	p	class:ctb::ctb	access:public	signature:(P....params)
ctb::ctb::load_instab	ctb.h	/^    template<template <typename Q, typename QQ, typename QQQ> class L, typename...P> void ctb<T,IT>::load_instab(P...params)$/;"	f	class:ctb::ctb	signature:(P....params)
ctb::ctb::process	ctb.h	/^        template<template <typename Q, typename QQ, typename QQQ> class L, typename M, typename...P> std::string process(std::string name, P...params) ;$/;"	p	class:ctb::ctb	access:public	signature:(std::string name, P...params)
ctb::ctb::process	ctb.h	/^    std::string ctb<T,IT>::process(std::string name, P...params)$/;"	f	class:ctb::ctb	signature:(std::string name, P...params)
ctb::ctb::self_test	ctb.h	/^        static void self_test() ;$/;"	p	class:ctb::ctb	access:public	signature:()
ctb::ctb::self_test	ctb.h	/^    void ctb<T,IT>::self_test()$/;"	f	class:ctb::ctb	signature:()
ctb::ctb_default	ctb.h	/^  typedef ctb<traits, instruction_table<traits> > ctb_default;$/;"	t	namespace:ctb
ctb::dummy	datatypes.h	/^  struct dummy$/;"	s	namespace:ctb
ctb::dummy::dummy	datatypes.h	/^      dummy(D...t){};$/;"	f	struct:ctb::dummy	access:public	signature:(D....t)
ctb::dummy_friend	datatypes.h	/^  struct dummy_friend$/;"	s	namespace:ctb
ctb::empty_tag	model.h	/^  struct empty_tag{};$/;"	s	namespace:ctb
ctb::fINPUT	datatypes.h	/^    fINPUT = 1, fOUTPUT = 2$/;"	e	enum:ctb::flags
ctb::fOUTPUT	datatypes.h	/^    fINPUT = 1, fOUTPUT = 2$/;"	e	enum:ctb::flags
ctb::fileexists	datatypes.h	/^  bool fileexists(char *name)$/;"	f	namespace:ctb	signature:(char *name)
ctb::flags	datatypes.h	/^  enum flags $/;"	g	namespace:ctb
ctb::friend_maker	datatypes.h	/^    struct friend_maker$/;"	s	namespace:ctb
ctb::friend_maker::type	datatypes.h	/^      typedef T type;$/;"	t	struct:ctb::friend_maker	access:public
ctb::generator	generator.h	/^    class generator$/;"	c	namespace:ctb
ctb::generator::addedge	generator.h	/^        void addedge(vid_t aid, vid_t bid, int b_argpos) ;$/;"	p	class:ctb::generator	access:public	signature:(vid_t aid, vid_t bid, int b_argpos)
ctb::generator::addedge	generator.h	/^    void generator<T,IT>::addedge(vid_t aid, vid_t bid, int b_argpos)  $/;"	f	class:ctb::generator	signature:(vid_t aid, vid_t bid, int b_argpos)
ctb::generator::addvert	generator.h	/^        template <typename...L> void addvert(vid_t v, id_t op, L... p) ;$/;"	p	class:ctb::generator	access:public	signature:(vid_t v, id_t op, L... p)
ctb::generator::addvert	generator.h	/^    template <typename...L> void generator<T,IT>::addvert(vid_t v, id_t op, L... p)  $/;"	f	class:ctb::generator	signature:(vid_t v, id_t op, L... p)
ctb::generator::data_t	generator.h	/^        class data_t$/;"	c	class:ctb::generator	access:private
ctb::generator::data_t::acces_map	generator.h	/^            acces_map_t acces_map;$/;"	m	class:ctb::generator::data_t	access:private
ctb::generator::data_t::acces_map_t	generator.h	/^            typedef std::map<int, writer<model_generator> > acces_map_t;$/;"	t	class:ctb::generator::data_t	access:private
ctb::generator::data_t::data_t	generator.h	/^            template <typename... L> data_t( node_t* me, const typename IT::operation_t* o, id_t opi, L&&... p);$/;"	p	class:ctb::generator::data_t	access:public	signature:( node_t* me, const typename IT::operation_t* o, id_t opi, L&&... p)
ctb::generator::data_t::data_t	generator.h	/^    generator<T,IT>::data_t::data_t( node_t* m, const typename IT::operation_t* o, id_t opi, L&&... p) : me(m), opid(opi), acces_map(), op(*o)$/;"	f	class:ctb::generator::data_t	signature:( node_t* m, const typename IT::operation_t* o, id_t opi, L&&... p)
ctb::generator::data_t::generate	generator.h	/^            template <class W> void generate(int granularity, W& w);$/;"	p	class:ctb::generator::data_t	access:public	signature:(int granularity, W& w)
ctb::generator::data_t::generate	generator.h	/^    void generator<T,IT>::data_t::generate(int granularity, W& w)$/;"	f	class:ctb::generator::data_t	signature:(int granularity, W& w)
ctb::generator::data_t::get_acces	generator.h	/^            template <class W> writer<model_generator> get_acces(int width, int gran, W& w);$/;"	p	class:ctb::generator::data_t	access:private	signature:(int width, int gran, W& w)
ctb::generator::data_t::get_acces	generator.h	/^    writer<model_generator> generator<T,IT>::data_t::get_acces(int width, int granularity, W& w)$/;"	f	class:ctb::generator::data_t	signature:(int width, int granularity, W& w)
ctb::generator::data_t::get_inout_pos	generator.h	/^            int get_inout_pos() const;$/;"	p	class:ctb::generator::data_t	access:public	signature:() const
ctb::generator::data_t::get_inout_pos	generator.h	/^    int generator<T,IT>::data_t::get_inout_pos() const$/;"	f	class:ctb::generator::data_t	signature:() const
ctb::generator::data_t::me	generator.h	/^            node_t* me;$/;"	m	class:ctb::generator::data_t	access:private
ctb::generator::data_t::newname	generator.h	/^            std::string newname(std::string tag) ;$/;"	p	class:ctb::generator::data_t	access:private	signature:(std::string tag)
ctb::generator::data_t::newname	generator.h	/^    std::string generator<T,IT>::data_t::newname(std::string tag)$/;"	f	class:ctb::generator::data_t	signature:(std::string tag)
ctb::generator::data_t::opid	generator.h	/^            proxy<id_t> opid;$/;"	m	class:ctb::generator::data_t	access:public
ctb::generator::data_t::parameters	generator.h	/^            std::vector<param_t> parameters;$/;"	m	class:ctb::generator::data_t	access:private
ctb::generator::data_t::push_params	generator.h	/^            template<typename P, typename...Ps> void push_params(P&&, Ps&&... params);$/;"	p	class:ctb::generator::data_t	access:private	signature:(P&&, Ps&&... params)
ctb::generator::data_t::push_params	generator.h	/^            void push_params();$/;"	p	class:ctb::generator::data_t	access:private	signature:()
ctb::generator::data_t::push_params	generator.h	/^    void generator<T,IT>::data_t::push_params()$/;"	f	class:ctb::generator::data_t	signature:()
ctb::generator::data_t::push_params	generator.h	/^    void generator<T,IT>::data_t::push_params(P&& p, Ps&&...params)$/;"	f	class:ctb::generator::data_t	signature:(P&& p, Ps&&...params)
ctb::generator::generate	generator.h	/^        template <class W> void generate(int granularity, W& w) ;$/;"	p	class:ctb::generator	access:public	signature:(int granularity, W& w)
ctb::generator::generate	generator.h	/^    void generator<T,IT>::generate(int packsize, W& w)$/;"	f	class:ctb::generator	signature:(int packsize, W& w)
ctb::generator::generator	generator.h	/^        generator(const IT& i);$/;"	p	class:ctb::generator	access:public	signature:(const IT& i)
ctb::generator::generator	generator.h	/^    generator<T,IT>::generator(const IT & i) : instab(i), graph()$/;"	f	class:ctb::generator	signature:(const IT & i)
ctb::generator::get_broadest	generator.h	/^        int get_broadest(int upperbound = 10000000) ;$/;"	p	class:ctb::generator	access:public	signature:(int upperbound = 10000000)
ctb::generator::get_broadest	generator.h	/^    int generator<T,IT>::get_broadest(int upperbound)$/;"	f	class:ctb::generator	signature:(int upperbound)
ctb::generator::graph	generator.h	/^        proxy<graph_t> graph;$/;"	m	class:ctb::generator	access:public
ctb::generator::graph_t	generator.h	/^        typedef graph_generic<data_t, typename T::vid_t, true, generator> graph_t;$/;"	t	class:ctb::generator	access:private
ctb::generator::id_t	generator.h	/^        typedef typename T::opid_t id_t;$/;"	t	class:ctb::generator	access:private
ctb::generator::instab	generator.h	/^        proxy<const IT&> instab;$/;"	m	class:ctb::generator	access:public
ctb::generator::node_t	generator.h	/^        typedef typename graph_t::node_t node_t;$/;"	t	class:ctb::generator	access:private
ctb::generator::op_t	generator.h	/^        typedef typename IT::operation_t op_t;$/;"	t	class:ctb::generator	access:private
ctb::generator::param_t	generator.h	/^        typedef typename T::param_t param_t;$/;"	t	class:ctb::generator	access:private
ctb::generator::vid_t	generator.h	/^        typedef typename T::vid_t vid_t;$/;"	t	class:ctb::generator	access:private
ctb::generator_default	generator.h	/^  typedef generator<traits, instruction_table_default> generator_default; $/;"	t	namespace:ctb
ctb::graph_default	graph.h	/^  typedef graph_generic<dummy,int,true> graph_default;$/;"	t	namespace:ctb
ctb::graph_generic	graph.h	/^    class graph_generic$/;"	c	namespace:ctb
ctb::graph_generic::addedge	graph.h	/^        void addedge(I aid, I bid, int b_argpos = -1) ;$/;"	p	class:ctb::graph_generic	access:public	signature:(I aid, I bid, int b_argpos = -1)
ctb::graph_generic::addedge	graph.h	/^    void graph_generic<T,I,directed,O...>::addedge(I aid, I bid, int b_argpos)  $/;"	f	class:ctb::graph_generic	signature:(I aid, I bid, int b_argpos)
ctb::graph_generic::addvert	graph.h	/^        template <typename...L> void addvert(I v, bool in , bool out , L&&... p) ;$/;"	p	class:ctb::graph_generic	access:public	signature:(I v, bool in , bool out , L&&... p)
ctb::graph_generic::addvert	graph.h	/^    void graph_generic<T,I,directed,O...>::addvert(I v, bool bin, bool bout, L&&... p)  $/;"	f	class:ctb::graph_generic	signature:(I v, bool bin, bool bout, L&&... p)
ctb::graph_generic::calculate_distances	graph.h	/^        void calculate_distances();$/;"	p	class:ctb::graph_generic	access:public	signature:()
ctb::graph_generic::calculate_distances	graph.h	/^    void graph_generic<T,I,directed,O...>::calculate_distances()  $/;"	f	class:ctb::graph_generic	signature:()
ctb::graph_generic::get_dist	graph.h	/^        int get_dist(I a, I b, I* c = NULL) const;$/;"	p	class:ctb::graph_generic	access:public	signature:(I a, I b, I* c = NULL) const
ctb::graph_generic::get_dist	graph.h	/^    int graph_generic<T,I,directed,O...>::get_dist(I a, I b, I* c) const$/;"	f	class:ctb::graph_generic	signature:(I a, I b, I* c) const
ctb::graph_generic::graph_generic	graph.h	/^        graph_generic();$/;"	p	class:ctb::graph_generic	access:public	signature:()
ctb::graph_generic::graph_generic	graph.h	/^    graph_generic<T,I,directed,O...>::graph_generic() : in(), out(), verts(), index(0)$/;"	f	class:ctb::graph_generic	signature:()
ctb::graph_generic::index	graph.h	/^        int index;$/;"	m	class:ctb::graph_generic	access:private
ctb::graph_generic::node	graph.h	/^        class node$/;"	c	class:ctb::graph_generic	access:private
ctb::graph_generic::node::crawl	graph.h	/^            template <bool recurse = false, bool inverse = false> void crawl(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q = NULL);$/;"	p	class:ctb::graph_generic::node	access:public	signature:(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q = NULL)
ctb::graph_generic::node::crawl	graph.h	/^    void graph_generic<T,I,directed,O...>::node::crawl(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q)$/;"	f	class:ctb::graph_generic::node	signature:(std::function<bool(node*)> f, std::function<bool(node*)> g, std::queue<node*>* q)
ctb::graph_generic::node::crawl_topological	graph.h	/^            void crawl_topological(std::function<void(node*)> f);$/;"	p	class:ctb::graph_generic::node	access:public	signature:(std::function<void(node*)> f)
ctb::graph_generic::node::crawl_topological	graph.h	/^    void graph_generic<T,I,directed,O...>::node::crawl_topological(std::function<void(node*)> f)$/;"	f	class:ctb::graph_generic::node	signature:(std::function<void(node*)> f)
ctb::graph_generic::node::get_path	graph.h	/^            node * get_path(node * n);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(node * n)
ctb::graph_generic::node::get_path	graph.h	/^    typename graph_generic<T,I,directed,O...>::node* graph_generic<T,I,directed,O...>::node::get_path(node * n)$/;"	f	class:ctb::graph_generic::node	signature:(node * n)
ctb::graph_generic::node::id	graph.h	/^            proxy<I> id;$/;"	m	class:ctb::graph_generic::node	access:public
ctb::graph_generic::node::in	graph.h	/^            proxy<std::vector<node*> > in;$/;"	m	class:ctb::graph_generic::node	access:public
ctb::graph_generic::node::index	graph.h	/^            int index;$/;"	m	class:ctb::graph_generic::node	access:private
ctb::graph_generic::node::init_map	graph.h	/^            bool init_map(int size);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(int size)
ctb::graph_generic::node::init_map	graph.h	/^    bool graph_generic<T,I,directed,O...>::node::init_map(int size)$/;"	f	class:ctb::graph_generic::node	signature:(int size)
ctb::graph_generic::node::lastpass	graph.h	/^            int lastpass;$/;"	m	class:ctb::graph_generic::node	access:private
ctb::graph_generic::node::map	graph.h	/^            mutable std::vector<route> map;$/;"	m	class:ctb::graph_generic::node	access:private
ctb::graph_generic::node::newid	graph.h	/^            int newid();$/;"	p	class:ctb::graph_generic::node	access:private	signature:()
ctb::graph_generic::node::newid	graph.h	/^    int graph_generic<T,I,directed,O...>::node::newid()$/;"	f	class:ctb::graph_generic::node	signature:()
ctb::graph_generic::node::node	graph.h	/^            template <typename... L> node(I vid, int index, L&&... p);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(I vid, int index, L&&... p)
ctb::graph_generic::node::node	graph.h	/^    graph_generic<T,I,directed,O...>::node::node(I vid, int idx, L&&... p) : id(vid), out(), in(), data(this, (std::forward<L>(p))...), index(idx)$/;"	f	class:ctb::graph_generic::node	signature:(I vid, int idx, L&&... p)
ctb::graph_generic::node::operator ->	graph.h	/^            proxy<T,O...>& operator->();$/;"	p	class:ctb::graph_generic::node	access:public	signature:()
ctb::graph_generic::node::operator ->	graph.h	/^    graph_generic<T,I,directed,O...>::node::proxy<T,O...>& graph_generic<T,I,directed,O...>::node::operator->()  $/;"	f	class:ctb::graph_generic::node	signature:()
ctb::graph_generic::node::out	graph.h	/^            proxy<std::vector<node*> > out;$/;"	m	class:ctb::graph_generic::node	access:public
ctb::graph_generic::node::parent	graph.h	/^            graph_generic* parent;$/;"	m	class:ctb::graph_generic::node	access:private
ctb::graph_generic::node::route	graph.h	/^            typedef std::pair<node*, int> route;$/;"	t	class:ctb::graph_generic::node	access:private
ctb::graph_generic::node::update_distances	graph.h	/^            bool update_distances();$/;"	p	class:ctb::graph_generic::node	access:private	signature:()
ctb::graph_generic::node::update_distances	graph.h	/^    bool graph_generic<T,I,directed,O...>::node::update_distances()$/;"	f	class:ctb::graph_generic::node	signature:()
ctb::graph_generic::node_t	graph.h	/^        typedef node node_t;$/;"	t	class:ctb::graph_generic	access:public
ctb::graph_generic::out	graph.h	/^        proxy<vertex_list_t> out;$/;"	m	class:ctb::graph_generic	access:public
ctb::graph_generic::self_test	graph.h	/^        static void self_test();$/;"	p	class:ctb::graph_generic	access:public	signature:()
ctb::graph_generic::self_test	graph.h	/^    void graph_generic<T,I,directed,O...>::self_test()$/;"	f	class:ctb::graph_generic	signature:()
ctb::graph_generic::vertex_container_t	graph.h	/^        typedef std::map<I, node*> vertex_container_t;$/;"	t	class:ctb::graph_generic	access:private
ctb::graph_generic::vertex_list_t	graph.h	/^        typedef std::vector<node*> vertex_list_t;$/;"	t	class:ctb::graph_generic	access:private
ctb::graph_generic::verts	graph.h	/^        proxy<vertex_container_t> verts;$/;"	m	class:ctb::graph_generic	access:public
ctb::instruction_table	instructions.h	/^    class instruction_table \/\/provides transition from opcode to abstract operation$/;"	c	namespace:ctb
ctb::instruction_table::addoperation	instructions.h	/^        \/*IAPI*\/ operation_t& addoperation(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f) ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)
ctb::instruction_table::addoperation	instructions.h	/^    typename instruction_table<T>::operation_t& instruction_table<T>::addoperation(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)$/;"	f	class:ctb::instruction_table	signature:(typename T::opid_t op, typename T::tid_t t, typename T::flag_t f)
ctb::instruction_table::addtype	instructions.h	/^        \/*IAPI*\/ type_t& addtype(typename T::tid_t t) ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::tid_t t)
ctb::instruction_table::addtype	instructions.h	/^    typename instruction_table<T>::type_t& instruction_table<T>::addtype(typename T::tid_t t)$/;"	f	class:ctb::instruction_table	signature:(typename T::tid_t t)
ctb::instruction_table::clear	instructions.h	/^        void clear() ; $/;"	p	class:ctb::instruction_table	access:public	signature:()
ctb::instruction_table::clear	instructions.h	/^    void instruction_table<T>::clear()  $/;"	f	class:ctb::instruction_table	signature:()
ctb::instruction_table::dec	instructions.h	/^        \/*API*\/ const operation_t& dec(typename T::opid_t type) const ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::opid_t type) const
ctb::instruction_table::dec	instructions.h	/^    const typename instruction_table<T>::operation_t& instruction_table<T>::dec(typename T::opid_t type)   const$/;"	f	class:ctb::instruction_table	signature:(typename T::opid_t type) const
ctb::instruction_table::dectype	instructions.h	/^        \/*API*\/ const type_t& dectype(typename T::tid_t type) const ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::tid_t type) const
ctb::instruction_table::dectype	instructions.h	/^    const typename instruction_table<T>::type_t& instruction_table<T>::dectype(typename T::tid_t type)   const$/;"	f	class:ctb::instruction_table	signature:(typename T::tid_t type) const
ctb::instruction_table::instab	instructions.h	/^        \/*EAPI*\/proxy<instab_t> instab;$/;"	m	class:ctb::instruction_table	access:public
ctb::instruction_table::instab_t	instructions.h	/^        typedef std::map<typename T::opid_t, operation*> instab_t;$/;"	t	class:ctb::instruction_table	access:private
ctb::instruction_table::operation	instructions.h	/^        class operation \/\/holds general operation traits$/;"	c	class:ctb::instruction_table	access:private
ctb::instruction_table::operation::addcode	instructions.h	/^            \/*IAPI*\/void addcode(int wi, int wo, const std::string& c);$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int wi, int wo, const std::string& c)
ctb::instruction_table::operation::addcode	instructions.h	/^    void instruction_table<T>::operation::addcode(int wi, int wo, const std::string& c)$/;"	f	class:ctb::instruction_table::operation	signature:(int wi, int wo, const std::string& c)
ctb::instruction_table::operation::flags	instructions.h	/^            \/*EAPI*\/proxy<typename T::flag_t> flags;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::get_conv_string	instructions.h	/^            \/*API*\/bool get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string& type)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int from, int to, std::string& c1, std::string& c2, std::string& type) const
ctb::instruction_table::operation::get_conv_string	instructions.h	/^    bool instruction_table<T>::operation::get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string& t) const$/;"	f	class:ctb::instruction_table::operation	signature:(int from, int to, std::string& c1, std::string& c2, std::string& t) const
ctb::instruction_table::operation::get_conversion_graph	instructions.h	/^            \/*API*\/const typename type::graph_distance_t& get_conversion_graph() const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:() const
ctb::instruction_table::operation::get_conversion_graph	instructions.h	/^    const typename instruction_table<T>::type::graph_distance_t& instruction_table<T>::operation::get_conversion_graph() const$/;"	f	class:ctb::instruction_table::operation	signature:() const
ctb::instruction_table::operation::get_max_width	instructions.h	/^            \/*API*\/int get_max_width(int bound = 1000000000, int* in = NULL, int* out = NULL)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int bound = 1000000000, int* in = NULL, int* out = NULL) const
ctb::instruction_table::operation::get_max_width	instructions.h	/^    int instruction_table<T>::operation::get_max_width(int bound, int* in, int* out)const$/;"	f	class:ctb::instruction_table::operation	signature:(int bound, int* in, int* out) const
ctb::instruction_table::operation::get_op_string	instructions.h	/^            \/*API*\/std::string get_op_string(int w = -1)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w = -1) const
ctb::instruction_table::operation::get_op_string	instructions.h	/^    std::string instruction_table<T>::operation::get_op_string(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
ctb::instruction_table::operation::get_type_string	instructions.h	/^            \/*API*\/std::string get_type_string(int w = -1)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w = -1) const
ctb::instruction_table::operation::get_type_string	instructions.h	/^    std::string instruction_table<T>::operation::get_type_string(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
ctb::instruction_table::operation::imbue_width	instructions.h	/^            \/*API*\/void imbue_width(int w)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w) const
ctb::instruction_table::operation::imbue_width	instructions.h	/^    void instruction_table<T>::operation::imbue_width(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
ctb::instruction_table::operation::imbued_width	instructions.h	/^            mutable int imbued_width;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::instruction	instructions.h	/^            struct instruction \/\/holds information for generation$/;"	s	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::instruction::code	instructions.h	/^              std::string code;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
ctb::instruction_table::operation::instruction::instruction	instructions.h	/^              instruction(int wi, int wo, const std::string& c);$/;"	p	struct:ctb::instruction_table::operation::instruction	access:public	signature:(int wi, int wo, const std::string& c)
ctb::instruction_table::operation::instruction::instruction	instructions.h	/^    instruction_table<T>::operation::instruction::instruction(int wi, int wo, const std::string& c) : code(c), width_in(wi), width_out(wo), width(std::max(wi, wo))$/;"	f	class:ctb::instruction_table::operation::instruction	signature:(int wi, int wo, const std::string& c)
ctb::instruction_table::operation::instruction::width	instructions.h	/^              int width;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
ctb::instruction_table::operation::instruction::width_in	instructions.h	/^              int width_in;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
ctb::instruction_table::operation::instruction::width_out	instructions.h	/^              int width_out;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
ctb::instruction_table::operation::is	instructions.h	/^            \/*API*\/bool is(typename T::flag_t f) const ;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(typename T::flag_t f) const
ctb::instruction_table::operation::is	instructions.h	/^    bool instruction_table<T>::operation::is(typename T::flag_t f) const $/;"	f	class:ctb::instruction_table::operation	signature:(typename T::flag_t f) const
ctb::instruction_table::operation::mytype	instructions.h	/^            \/*EAPI*\/proxy<type*> mytype;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::operation	instructions.h	/^            operation(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t);$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t)
ctb::instruction_table::operation::operation	instructions.h	/^    instruction_table<T>::operation::operation(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t) : opid(i), mytype(t), out_type(ot), flags(f)$/;"	f	class:ctb::instruction_table::operation	signature:(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t)
ctb::instruction_table::operation::opid	instructions.h	/^            \/*EAPI*\/proxy<typename T::opid_t> opid;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::out_type	instructions.h	/^            \/*EAPI*\/proxy<typename T::tid_t> out_type;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation::versions	instructions.h	/^            \/*EAPI*\/proxy<std::vector<instruction>> versions;$/;"	m	class:ctb::instruction_table::operation	access:private
ctb::instruction_table::operation_t	instructions.h	/^        typedef operation operation_t; $/;"	t	class:ctb::instruction_table	access:public
ctb::instruction_table::type	instructions.h	/^        class type$/;"	c	class:ctb::instruction_table	access:private
ctb::instruction_table::type::addcode_conversion	instructions.h	/^          \/*IAPI*\/void addcode_conversion(int from, int to, const std::string& c1, const std::string& c2);$/;"	p	class:ctb::instruction_table::type	access:public	signature:(int from, int to, const std::string& c1, const std::string& c2)
ctb::instruction_table::type::addcode_conversion	instructions.h	/^    void instruction_table<T>::type::addcode_conversion(int in, int out, const std::string& c1,const std::string& c2)$/;"	f	class:ctb::instruction_table::type	signature:(int in, int out, const std::string& c1,const std::string& c2)
ctb::instruction_table::type::addcode_type	instructions.h	/^          \/*IAPI*\/void addcode_type(int w, const std::string& c) ;$/;"	p	class:ctb::instruction_table::type	access:public	signature:(int w, const std::string& c)
ctb::instruction_table::type::addcode_type	instructions.h	/^    void instruction_table<T>::type::addcode_type(int w, const std::string& c)$/;"	f	class:ctb::instruction_table::type	signature:(int w, const std::string& c)
ctb::instruction_table::type::conversion	instructions.h	/^          struct conversion$/;"	s	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type::conversion::code1	instructions.h	/^            const std::string code1;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
ctb::instruction_table::type::conversion::code2	instructions.h	/^            const std::string code2;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
ctb::instruction_table::type::conversion::conversion	instructions.h	/^            conversion(int in, int out, const std::string& c1, const std::string& c2);$/;"	p	struct:ctb::instruction_table::type::conversion	access:public	signature:(int in, int out, const std::string& c1, const std::string& c2)
ctb::instruction_table::type::conversion::conversion	instructions.h	/^    instruction_table<T>::type::conversion::conversion(int i, int o, const std::string& c1, const std::string& c2) : width_in(i), width_out(o), code1(c1), code2(c2)$/;"	f	class:ctb::instruction_table::type::conversion	signature:(int i, int o, const std::string& c1, const std::string& c2)
ctb::instruction_table::type::conversion::width_in	instructions.h	/^            const int width_in;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
ctb::instruction_table::type::conversion::width_out	instructions.h	/^            const int width_out;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
ctb::instruction_table::type::conversions	instructions.h	/^          \/*EAPI*\/proxy<std::vector<conversion>> conversions;$/;"	m	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type::distances	instructions.h	/^          mutable graph_distance_t distances; \/\/technically taken just a cache$/;"	m	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type::graph_distance_t	instructions.h	/^          typedef graph_generic<dummy, int, false, type> graph_distance_t;$/;"	t	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type::type_version	instructions.h	/^          struct type_version$/;"	s	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type::type_version::code	instructions.h	/^            const std::string code;$/;"	m	struct:ctb::instruction_table::type::type_version	access:public
ctb::instruction_table::type::type_version::type_version	instructions.h	/^            type_version(int w, const std::string& c);$/;"	p	struct:ctb::instruction_table::type::type_version	access:public	signature:(int w, const std::string& c)
ctb::instruction_table::type::type_version::type_version	instructions.h	/^    instruction_table<T>::type::type_version::type_version(int w, const std::string& c) : width(w), code(c)$/;"	f	class:ctb::instruction_table::type::type_version	signature:(int w, const std::string& c)
ctb::instruction_table::type::type_version::width	instructions.h	/^            const int width;$/;"	m	struct:ctb::instruction_table::type::type_version	access:public
ctb::instruction_table::type::versions	instructions.h	/^          \/*EAPI*\/proxy<std::vector<type_version>> versions;$/;"	m	class:ctb::instruction_table::type	access:public
ctb::instruction_table::type_t	instructions.h	/^        typedef type type_t; $/;"	t	class:ctb::instruction_table	access:public
ctb::instruction_table::typetab	instructions.h	/^        \/*EAPI*\/proxy<typetable_t> typetab;$/;"	m	class:ctb::instruction_table	access:public
ctb::instruction_table::typetable_t	instructions.h	/^        typedef std::map<typename T::tid_t, type*> typetable_t;$/;"	t	class:ctb::instruction_table	access:private
ctb::instruction_table_default	instructions.h	/^  typedef instruction_table<traits> instruction_table_default;$/;"	t	namespace:ctb
ctb::language_cpp	languages.h	/^    class language_cpp$/;"	c	namespace:ctb
ctb::language_cpp::shouldbreak	languages.h	/^        static void shouldbreak(const int& pos, const std::string& format, bool& brbf, bool& braf)$/;"	f	class:ctb::language_cpp	access:public	signature:(const int& pos, const std::string& format, bool& brbf, bool& braf)
ctb::language_cpp::shouldindent	languages.h	/^        static void shouldindent( const std::string& line, int& outindent, int& indent, int& nobreak)$/;"	f	class:ctb::language_cpp	access:public	signature:( const std::string& line, int& outindent, int& indent, int& nobreak)
ctb::language_empty	languages.h	/^    class language_empty$/;"	c	namespace:ctb
ctb::language_empty::shouldbreak	languages.h	/^        static void shouldbreak(const int& pos, const std::string&, bool& brbf, bool& braf)$/;"	f	class:ctb::language_empty	access:public	signature:(const int& pos, const std::string&, bool& brbf, bool& braf)
ctb::language_empty::shouldindent	languages.h	/^        static void shouldindent( const std::string&, int& outindent, int& indent, int& nobreak)$/;"	f	class:ctb::language_empty	access:public	signature:( const std::string&, int& outindent, int& indent, int& nobreak)
ctb::loader_default	xmlloader.h	/^  typedef xml_loader<traits, generator_default, instruction_table_default> loader_default;$/;"	t	namespace:ctb
ctb::model_bobox	model_bobox.h	/^  class model_bobox : public model_generator$/;"	c	namespace:ctb	inherits:model_generator
ctb::model_bobox::alias	model_bobox.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_bobox	access:public	signature:(const std::string& a)
ctb::model_bobox::alias	model_bobox.h	/^  std::string model_bobox::alias(const std::string& a)$/;"	f	class:ctb::model_bobox	signature:(const std::string& a)
ctb::model_bobox::aliases	model_bobox.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_bobox	access:protected
ctb::model_bobox::aliases	model_bobox.h	/^  std::map<std::string, std::string> model_bobox::aliases;$/;"	m	class:ctb::model_bobox
ctb::model_bobox::aliastab_t	model_bobox.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_bobox	access:protected
ctb::model_bobox::generate	model_bobox.h	/^      template <class G> static writer<model_bobox> generate(int m,  G& generator, std::string name);$/;"	p	class:ctb::model_bobox	access:public	signature:(int m, G& generator, std::string name)
ctb::model_bobox::generate	model_bobox.h	/^    writer<model_bobox> model_bobox::generate(int max_granularity, G& generator, std::string name)$/;"	f	class:ctb::model_bobox	signature:(int max_granularity, G& generator, std::string name)
ctb::model_bobox::init	model_bobox.h	/^      static void init();$/;"	p	class:ctb::model_bobox	access:protected	signature:()
ctb::model_bobox::init	model_bobox.h	/^  void model_bobox::init()$/;"	f	class:ctb::model_bobox	signature:()
ctb::model_bobox::language	model_bobox.h	/^      typedef language_cpp language;$/;"	t	class:ctb::model_bobox	access:public
ctb::model_empty	model.h	/^  typedef model_maker<empty_tag, language_empty> model_empty;$/;"	t	namespace:ctb
ctb::model_empty_cpp	model.h	/^  typedef model_maker<empty_tag, language_cpp> model_empty_cpp;$/;"	t	namespace:ctb
ctb::model_generator	model_generator.h	/^  class model_generator $/;"	c	namespace:ctb
ctb::model_generator::alias	model_generator.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_generator	access:public	signature:(const std::string& a)
ctb::model_generator::alias	model_generator.h	/^  std::string model_generator::alias(const std::string& a)$/;"	f	class:ctb::model_generator	signature:(const std::string& a)
ctb::model_generator::aliases	model_generator.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_generator	access:protected
ctb::model_generator::aliases	model_generator.h	/^  std::map<std::string, std::string> model_generator::aliases;$/;"	m	class:ctb::model_generator
ctb::model_generator::aliastab_t	model_generator.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_generator	access:protected
ctb::model_generator::generate	model_generator.h	/^      template <class G> static writer<model_generator> generate(int m,  G& graph, std::string name) ;$/;"	p	class:ctb::model_generator	access:public	signature:(int m, G& graph, std::string name)
ctb::model_generator::generate	model_generator.h	/^    writer<model_generator> model_generator::generate(int max_granularity, G& graph, std::string name)$/;"	f	class:ctb::model_generator	signature:(int max_granularity, G& graph, std::string name)
ctb::model_generator::init	model_generator.h	/^      static void init();$/;"	p	class:ctb::model_generator	access:protected	signature:()
ctb::model_generator::init	model_generator.h	/^  void model_generator::init()$/;"	f	class:ctb::model_generator	signature:()
ctb::model_generator::language	model_generator.h	/^      typedef language_empty language;$/;"	t	class:ctb::model_generator	access:public
ctb::model_maker	model.h	/^  class model_maker$/;"	c	namespace:ctb
ctb::model_maker::access	model.h	/^      static std::string& access(const std::string&);$/;"	p	class:ctb::model_maker	access:public	signature:(const std::string&)
ctb::model_maker::access	model.h	/^  std::string& model_maker<T,L>::access(const std::string& str)$/;"	f	class:ctb::model_maker	signature:(const std::string& str)
ctb::model_maker::alias	model.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_maker	access:public	signature:(const std::string& a)
ctb::model_maker::alias	model.h	/^  std::string model_maker<T,L>::alias(const std::string& a)$/;"	f	class:ctb::model_maker	signature:(const std::string& a)
ctb::model_maker::aliases	model.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_maker	access:protected
ctb::model_maker::aliases	model.h	/^  template <typename T, typename L> std::map<std::string, std::string> model_maker<T,L>::aliases;$/;"	m	class:ctb::model_maker
ctb::model_maker::aliastab_t	model.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_maker	access:protected
ctb::model_maker::clear	model.h	/^      static void clear();$/;"	p	class:ctb::model_maker	access:public	signature:()
ctb::model_maker::clear	model.h	/^  void model_maker<T,L>::clear()$/;"	f	class:ctb::model_maker	signature:()
ctb::model_maker::init	model.h	/^      static void init();$/;"	p	class:ctb::model_maker	access:protected	signature:()
ctb::model_maker::init	model.h	/^  void model_maker<T,L>::init()$/;"	f	class:ctb::model_maker	signature:()
ctb::model_maker::language	model.h	/^      typedef L language;$/;"	t	class:ctb::model_maker	access:public
ctb::model_simple	model_simple.h	/^  class model_simple : public model_generator$/;"	c	namespace:ctb	inherits:model_generator
ctb::model_simple::alias	model_simple.h	/^      static std::string alias(const std::string& a);$/;"	p	class:ctb::model_simple	access:public	signature:(const std::string& a)
ctb::model_simple::alias	model_simple.h	/^  std::string model_simple::alias(const std::string& a)$/;"	f	class:ctb::model_simple	signature:(const std::string& a)
ctb::model_simple::aliases	model_simple.h	/^      static aliastab_t aliases;$/;"	m	class:ctb::model_simple	access:protected
ctb::model_simple::aliases	model_simple.h	/^  std::map<std::string, std::string> model_simple::aliases;$/;"	m	class:ctb::model_simple
ctb::model_simple::aliastab_t	model_simple.h	/^      typedef std::map<std::string, std::string> aliastab_t;$/;"	t	class:ctb::model_simple	access:protected
ctb::model_simple::generate	model_simple.h	/^      template <class G> static writer<model_simple> generate(int m,  G& generator, std::string name);$/;"	p	class:ctb::model_simple	access:public	signature:(int m, G& generator, std::string name)
ctb::model_simple::generate	model_simple.h	/^    writer<model_simple> model_simple::generate(int granularity, G& generator, std::string name)$/;"	f	class:ctb::model_simple	signature:(int granularity, G& generator, std::string name)
ctb::model_simple::init	model_simple.h	/^      static void init();$/;"	p	class:ctb::model_simple	access:protected	signature:()
ctb::model_simple::init	model_simple.h	/^  void model_simple::init()$/;"	f	class:ctb::model_simple	signature:()
ctb::model_simple::language	model_simple.h	/^      typedef language_cpp language;$/;"	t	class:ctb::model_simple	access:public
ctb::pass	datatypes.h	/^  template <typename ... T> void pass(T...)$/;"	f	namespace:ctb	signature:(T....)
ctb::print	model.h	/^  template<bool dolars = false, typename ... Types> std::string print (const Types&... params)$/;"	f	namespace:ctb	signature:(const Types&.... params)
ctb::proxy_	datatypes.h	/^    class proxy_ {$/;"	c	namespace:ctb
ctb::proxy_::br_ct	datatypes.h	/^      template <typename U> struct br_ct  { typedef decltype(std::declval<T const>()[std::declval<U>()]) type; };$/;"	s	class:ctb::proxy_	access:private
ctb::proxy_::br_ct::type	datatypes.h	/^      template <typename U> struct br_ct  { typedef decltype(std::declval<T const>()[std::declval<U>()]) type; };$/;"	t	struct:ctb::proxy_::br_ct	access:public
ctb::proxy_::br_t	datatypes.h	/^      template <typename U> struct br_t { typedef decltype(std::declval<T      >()[std::declval<U>()]) type; };$/;"	s	class:ctb::proxy_	access:private
ctb::proxy_::br_t::type	datatypes.h	/^      template <typename U> struct br_t { typedef decltype(std::declval<T      >()[std::declval<U>()]) type; };$/;"	t	struct:ctb::proxy_::br_t	access:public
ctb::proxy_::data	datatypes.h	/^      T data;$/;"	m	class:ctb::proxy_	access:private
ctb::proxy_::operator *	datatypes.h	/^      const T& operator*() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
ctb::proxy_::operator ->	datatypes.h	/^      const result_t* operator->() const { return &data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
ctb::proxy_::operator []	datatypes.h	/^      template <typename U> typename br_ct<U>::type operator [](U args) const { return data[args]; }$/;"	f	class:ctb::proxy_	access:public	signature:(U args) const
ctb::proxy_::operator const T&	datatypes.h	/^      operator const T&() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
ctb::proxy_::proxy_	datatypes.h	/^      template <typename...L> proxy_(L&&... args) : data((std::forward<L>(args))...){}$/;"	f	class:ctb::proxy_	access:public	signature:(L&&.... args)
ctb::proxy_::r	datatypes.h	/^      const result_t& r() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
ctb::proxy_::result_t	datatypes.h	/^      typedef typename std::remove_reference<T>::type result_t;$/;"	t	class:ctb::proxy_	access:private
ctb::proxy_::rw	datatypes.h	/^      result_t& rw() { return data; }$/;"	f	class:ctb::proxy_	access:private	signature:()
ctb::stoi	datatypes.h	/^  int stoi(std::string str)$/;"	f	namespace:ctb	signature:(std::string str)
ctb::stringlist	datatypes.h	/^  typedef std::vector<std::string> stringlist;$/;"	t	namespace:ctb
ctb::traits	datatypes.h	/^  struct traits$/;"	s	namespace:ctb
ctb::traits::flag_t	datatypes.h	/^    typedef int flag_t;$/;"	t	struct:ctb::traits	access:public
ctb::traits::maxarity	datatypes.h	/^    static const int maxarity = 3;$/;"	m	struct:ctb::traits	access:public
ctb::traits::opid_t	datatypes.h	/^    typedef std::string opid_t;$/;"	t	struct:ctb::traits	access:public
ctb::traits::param_t	datatypes.h	/^    typedef int param_t;$/;"	t	struct:ctb::traits	access:public
ctb::traits::tid_t	datatypes.h	/^    typedef std::string tid_t;$/;"	t	struct:ctb::traits	access:public
ctb::traits::vid_t	datatypes.h	/^    typedef std::string vid_t;$/;"	t	struct:ctb::traits	access:public
ctb::writer	writer.h	/^    class writer \/\/will provide methods for outputting the generated code - e.g. autoindent, output to files or stdout$/;"	c	namespace:ctb
ctb::writer::add	writer.h	/^        void add(std::string&& str, bool terminal) ;$/;"	p	class:ctb::writer	access:private	signature:(std::string&& str, bool terminal)
ctb::writer::add	writer.h	/^    void writer<M>::add(std::string&& str, bool terminal)$/;"	f	class:ctb::writer	signature:(std::string&& str, bool terminal)
ctb::writer::append	writer.h	/^        template <bool dolars = false, typename Types> writer<M>& append(Types str) ;$/;"	p	class:ctb::writer	access:public	signature:(Types str)
ctb::writer::append	writer.h	/^    template <bool dolars , typename Types> writer<M>& writer<M>::append(Types str)$/;"	f	class:ctb::writer	signature:(Types str)
ctb::writer::clear	writer.h	/^        void clear() ;$/;"	p	class:ctb::writer	access:public	signature:()
ctb::writer::clear	writer.h	/^    void writer<M>::clear()  $/;"	f	class:ctb::writer	signature:()
ctb::writer::data	writer.h	/^        std::vector<std::string> data;$/;"	m	class:ctb::writer	access:private
ctb::writer::from_file	writer.h	/^        static std::string from_file(const std::string& filename);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename)
ctb::writer::from_file	writer.h	/^    std::string writer<M>::from_file(const std::string& filename)$/;"	f	class:ctb::writer	signature:(const std::string& filename)
ctb::writer::get_name	writer.h	/^        std::string get_name(const std::string& format, int& pos);$/;"	p	class:ctb::writer	access:private	signature:(const std::string& format, int& pos)
ctb::writer::get_name	writer.h	/^    std::string writer<M>::get_name(const std::string& format, int& pos)$/;"	f	class:ctb::writer	signature:(const std::string& format, int& pos)
ctb::writer::get_string	writer.h	/^        std::string get_string() const; \/\/does handle dolars internally!$/;"	p	class:ctb::writer	access:private	signature:() const
ctb::writer::get_string	writer.h	/^    std::string writer<M>::get_string() const$/;"	f	class:ctb::writer	signature:() const
ctb::writer::getnth	writer.h	/^        template <typename ... Types> const writer<M>& getnth(int i, const writer<M>& a, const Types&... params);$/;"	p	class:ctb::writer	access:private	signature:(int i, const writer<M>& a, const Types&... params)
ctb::writer::getnth	writer.h	/^        writer<M> getnth(int i);$/;"	p	class:ctb::writer	access:private	signature:(int i)
ctb::writer::getnth	writer.h	/^    template <typename ... Types> const writer<M>& writer<M>::getnth(int i, const writer<M>& a, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const writer<M>& a, const Types&... params)
ctb::writer::getnth	writer.h	/^    writer<M> writer<M>::getnth(int i)$/;"	f	class:ctb::writer	signature:(int i)
ctb::writer::last_terminated	writer.h	/^        bool last_terminated;$/;"	m	class:ctb::writer	access:private
ctb::writer::list_concat	writer.h	/^        writer& list_concat(const std::string& delim);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& delim)
ctb::writer::list_concat	writer.h	/^    writer<M> &writer<M>::list_concat(const std::string& delim)$/;"	f	class:ctb::writer	signature:(const std::string& delim)
ctb::writer::operator !=	writer.h	/^        bool operator!=(const writer& w) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& w)
ctb::writer::operator !=	writer.h	/^    bool writer<M>::operator!=(const writer& w)$/;"	f	class:ctb::writer	signature:(const writer& w)
ctb::writer::operator =	writer.h	/^        template<typename N> writer& operator=( const writer<N>& w) ;$/;"	p	class:ctb::writer	access:public	signature:( const writer<N>& w)
ctb::writer::operator =	writer.h	/^        template<typename N> writer& operator=( writer<N>&& w) ;$/;"	p	class:ctb::writer	access:public	signature:( writer<N>&& w)
ctb::writer::operator =	writer.h	/^    writer<M>& writer<M>::operator=(const writer<N>& w)$/;"	f	class:ctb::writer	signature:(const writer<N>& w)
ctb::writer::operator =	writer.h	/^    writer<M>& writer<M>::operator=(writer<N>&& w)$/;"	f	class:ctb::writer	signature:(writer<N>&& w)
ctb::writer::operator ==	writer.h	/^        bool operator==(const writer& w) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& w)
ctb::writer::operator ==	writer.h	/^    bool writer<M>::operator==(const writer& w)$/;"	f	class:ctb::writer	signature:(const writer& w)
ctb::writer::print	writer.h	/^        template<bool dolars = false, typename ... Types> writer& print (const std::string& format, const Types&... params) ; \/**should accept at least string and another writer class e.g. print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j*\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& format, const Types&... params)
ctb::writer::print	writer.h	/^        template<bool dolars = false, typename ... Types> writer& print (const writer& format, const Types&... params) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& format, const Types&... params)
ctb::writer::print	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print(const std::string& format, const Types&... params)  \/\/print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	f	class:ctb::writer	signature:(const std::string& format, const Types&... params)
ctb::writer::print	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print(const writer& format, const Types&... params)$/;"	f	class:ctb::writer	signature:(const writer& format, const Types&... params)
ctb::writer::print_internal	writer.h	/^        template<bool dolars, typename ... Types> writer& print_internal (const std::string& format, const Types&... params) ; \/\/should accept at least string and another writer class e.g. print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	p	class:ctb::writer	access:private	signature:(const std::string& format, const Types&... params)
ctb::writer::print_internal	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print_internal(const std::string& format, const Types&... params)  \/\/print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	f	class:ctb::writer	signature:(const std::string& format, const Types&... params)
ctb::writer::printf	writer.h	/^        template<bool dolars = false, typename ... Types> writer& printf(const std::string& filename, const Types&... params) ; \/** print, but the first argument is a filename of a file which is to be loaded instead of the format string *\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const Types&... params)
ctb::writer::printf	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::printf(const std::string& filename, const Types&... params)$/;"	f	class:ctb::writer	signature:(const std::string& filename, const Types&... params)
ctb::writer::printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const int& num, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const int& num, const Types&... params)
ctb::writer::printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const std::string& str, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const std::string& str, const Types&... params)
ctb::writer::printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const writer& wrt, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const writer& wrt, const Types&... params)
ctb::writer::printnth	writer.h	/^        void printnth(int i);$/;"	p	class:ctb::writer	access:private	signature:(int i)
ctb::writer::printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const int& num, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const int& num, const Types&... params)
ctb::writer::printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const std::string& str, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const std::string& str, const Types&... params)
ctb::writer::printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const writer& wrt, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const writer& wrt, const Types&... params)
ctb::writer::printnth	writer.h	/^    void writer<M>::printnth(int i)$/;"	f	class:ctb::writer	signature:(int i)
ctb::writer::process	writer.h	/^        void process(int& pos, const std::string& format) ;$/;"	p	class:ctb::writer	access:private	signature:(int& pos, const std::string& format)
ctb::writer::process	writer.h	/^    void writer<M>::process(int& pos, const std::string& format)$/;"	f	class:ctb::writer	signature:(int& pos, const std::string& format)
ctb::writer::push	writer.h	/^        template<bool dolars = false, typename ... Types, typename Type> writer& push  (const Type& format, const Types&... params) ; \/** explicit push on a new line. To be used with list_concat for simple creation of delimited lists.*\/$/;"	p	class:ctb::writer	access:public	signature:(const Type& format, const Types&... params)
ctb::writer::push	writer.h	/^    template<bool dolars , typename ... Types, typename Type> writer<M>& writer<M>::push(const Type& format, const Types&... params)$/;"	f	class:ctb::writer	signature:(const Type& format, const Types&... params)
ctb::writer::pushf	writer.h	/^        template<bool dolars = false, typename ... Types> writer& pushf (const std::string& filename, const Types&... params) ; \/** pushf is again a file-loaded version of push *\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const Types&... params)
ctb::writer::pushf	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::pushf(const std::string& filename, const Types&... params)$/;"	f	class:ctb::writer	signature:(const std::string& filename, const Types&... params)
ctb::writer::self_test	writer.h	/^        static void self_test() ;$/;"	p	class:ctb::writer	access:public	signature:()
ctb::writer::self_test	writer.h	/^    void writer<M>::self_test()$/;"	f	class:ctb::writer	signature:()
ctb::writer::to_file	writer.h	/^        static void to_file(const std::string& filename, const std::string& contents);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const std::string& contents)
ctb::writer::to_file	writer.h	/^    void writer<M>::to_file(const std::string& filename,const std::string& contents)$/;"	f	class:ctb::writer	signature:(const std::string& filename,const std::string& contents)
ctb::writer::to_writer	writer.h	/^        const writer<M>& to_writer(const writer<M>& r);$/;"	p	class:ctb::writer	access:private	signature:(const writer<M>& r)
ctb::writer::to_writer	writer.h	/^        writer<M> to_writer(const int& r);$/;"	p	class:ctb::writer	access:private	signature:(const int& r)
ctb::writer::to_writer	writer.h	/^        writer<M> to_writer(const std::string& r);$/;"	p	class:ctb::writer	access:private	signature:(const std::string& r)
ctb::writer::to_writer	writer.h	/^    const writer<M>& writer<M>::to_writer(const writer<M>& r)$/;"	f	class:ctb::writer	signature:(const writer<M>& r)
ctb::writer::to_writer	writer.h	/^    writer<M> writer<M>::to_writer(const int& r)$/;"	f	class:ctb::writer	signature:(const int& r)
ctb::writer::to_writer	writer.h	/^    writer<M> writer<M>::to_writer(const std::string& r)$/;"	f	class:ctb::writer	signature:(const std::string& r)
ctb::writer::trim	writer.h	/^        void trim() ;$/;"	p	class:ctb::writer	access:private	signature:()
ctb::writer::trim	writer.h	/^    void writer<M>::trim()$/;"	f	class:ctb::writer	signature:()
ctb::writer::write	writer.h	/^        void write(std::ostream& ss) ;$/;"	p	class:ctb::writer	access:public	signature:(std::ostream& ss)
ctb::writer::write	writer.h	/^    void writer<M>::write(std::ostream& ss) $/;"	f	class:ctb::writer	signature:(std::ostream& ss)
ctb::writer::write_file	writer.h	/^        void write_file(std::string filename) ; $/;"	p	class:ctb::writer	access:public	signature:(std::string filename)
ctb::writer::write_file	writer.h	/^    void writer<M>::write_file(std::string filename)  $/;"	f	class:ctb::writer	signature:(std::string filename)
ctb::writer::write_indent	writer.h	/^        void write_indent(std::ostream& ss, const std::string& str, int indent, int nobreak) ;$/;"	p	class:ctb::writer	access:private	signature:(std::ostream& ss, const std::string& str, int indent, int nobreak)
ctb::writer::write_indent	writer.h	/^    void writer<M>::write_indent(std::ostream& ss, const std::string& str, int indent, int nobreak)$/;"	f	class:ctb::writer	signature:(std::ostream& ss, const std::string& str, int indent, int nobreak)
ctb::writer::write_std	writer.h	/^        void write_std() ; $/;"	p	class:ctb::writer	access:public	signature:()
ctb::writer::write_std	writer.h	/^    void writer<M>::write_std()  $/;"	f	class:ctb::writer	signature:()
ctb::writer::write_str	writer.h	/^        std::string write_str() ;$/;"	p	class:ctb::writer	access:public	signature:()
ctb::writer::write_str	writer.h	/^    std::string writer<M>::write_str()$/;"	f	class:ctb::writer	signature:()
ctb::writer::writer	writer.h	/^        template<typename N> writer(const writer<N>& writer);$/;"	p	class:ctb::writer	access:public	signature:(const writer<N>& writer)
ctb::writer::writer	writer.h	/^        template<typename N> writer(writer<N>&& writer);$/;"	p	class:ctb::writer	access:public	signature:(writer<N>&& writer)
ctb::writer::writer	writer.h	/^        writer();$/;"	p	class:ctb::writer	access:public	signature:()
ctb::writer::writer	writer.h	/^        writer(const std::initializer_list<std::string>& init);\/*this one is literal! no parsing here*\/$/;"	p	class:ctb::writer	access:public	signature:(const std::initializer_list<std::string>& init)
ctb::writer::writer	writer.h	/^    writer<M>::writer() : data(), last_terminated(true)$/;"	f	class:ctb::writer	signature:()
ctb::writer::writer	writer.h	/^    writer<M>::writer(const std::initializer_list<std::string>& init) : data(init), last_terminated(true)\/*the strings are taken literary - id est not formatted*\/$/;"	f	class:ctb::writer	signature:(const std::initializer_list<std::string>& init)
ctb::writer::writer	writer.h	/^    writer<M>::writer(const writer<N>& w) : data(w.data), last_terminated(w.last_terminated)$/;"	f	class:ctb::writer	signature:(const writer<N>& w)
ctb::writer::writer	writer.h	/^    writer<M>::writer(writer<N>&& w) : data(std::move(w.data)), last_terminated(w.last_terminated)$/;"	f	class:ctb::writer	signature:(writer<N>&& w)
ctb::writer_default	model.h	/^  typedef writer<model_empty_cpp> writer_default;$/;"	t	namespace:ctb
ctb::xml_loader	xmlloader.h	/^    class xml_loader$/;"	c	namespace:ctb
ctb::xml_loader::getanystr	xmlloader.h	/^        static std::string getanystr(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::getanystr	xmlloader.h	/^    std::string xml_loader<T,G,IT>::getanystr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::getint	xmlloader.h	/^        static int getint(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::getint	xmlloader.h	/^    int xml_loader<T,G,IT>::getint(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::getstr	xmlloader.h	/^        static std::string getstr(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::getstr	xmlloader.h	/^    std::string xml_loader<T,G,IT>::getstr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::hasval	xmlloader.h	/^        static bool hasval(tinyxml2::XMLNode* node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode* node, std::string name)
ctb::xml_loader::hasval	xmlloader.h	/^    bool xml_loader<T,G,IT>::hasval(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
ctb::xml_loader::load_graph	xmlloader.h	/^        static void load_graph(G& graph, std::string filename) ;$/;"	p	class:ctb::xml_loader	access:public	signature:(G& graph, std::string filename)
ctb::xml_loader::load_graph	xmlloader.h	/^    void xml_loader<T,G,IT>::load_graph(G& graph, std::string filename)$/;"	f	class:ctb::xml_loader	signature:(G& graph, std::string filename)
ctb::xml_loader::load_instab	xmlloader.h	/^        static void load_instab(IT& instab, std::string filename) ;$/;"	p	class:ctb::xml_loader	access:public	signature:(IT& instab, std::string filename)
ctb::xml_loader::load_instab	xmlloader.h	/^    void xml_loader<T,G,IT>::load_instab(IT& instab, std::string filename)$/;"	f	class:ctb::xml_loader	signature:(IT& instab, std::string filename)
ctb::xml_loader::self_test	xmlloader.h	/^        static void self_test() ;$/;"	p	class:ctb::xml_loader	access:public	signature:()
ctb::xml_loader::self_test	xmlloader.h	/^    void xml_loader<T,G,IT>::self_test()$/;"	f	class:ctb::xml_loader	signature:()
ctb_GUARD	ctb.h	2;"	d
ctb_default	ctb.h	/^  typedef ctb<traits, instruction_table<traits> > ctb_default;$/;"	t	namespace:ctb
data	datatypes.h	/^      T data;$/;"	m	class:ctb::proxy_	access:private
data	writer.h	/^        std::vector<std::string> data;$/;"	m	class:ctb::writer	access:private
data_in_$1	templates/simple_decl_in.h	/^$2 * data_in_$1 = NULL;$/;"	v
data_out_$1	templates/bobox_decl_in.h	/^const $2 * data_out_$1;$/;"	v
data_out_$1	templates/bobox_decl_out.h	/^$2 * data_out_$1;$/;"	v
data_out_$1	templates/simple_decl_out.h	/^$2 * data_out_$1 = NULL;$/;"	v
data_t	generator.h	/^            template <typename... L> data_t( node_t* me, const typename IT::operation_t* o, id_t opi, L&&... p);$/;"	p	class:ctb::generator::data_t	access:public	signature:( node_t* me, const typename IT::operation_t* o, id_t opi, L&&... p)
data_t	generator.h	/^        class data_t$/;"	c	class:ctb::generator	access:private
data_t	generator.h	/^    generator<T,IT>::data_t::data_t( node_t* m, const typename IT::operation_t* o, id_t opi, L&&... p) : me(m), opid(opi), acces_map(), op(*o)$/;"	f	class:ctb::generator::data_t	signature:( node_t* m, const typename IT::operation_t* o, id_t opi, L&&... p)
dec	instructions.h	/^        \/*API*\/ const operation_t& dec(typename T::opid_t type) const ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::opid_t type) const
dec	instructions.h	/^    const typename instruction_table<T>::operation_t& instruction_table<T>::dec(typename T::opid_t type)   const$/;"	f	class:ctb::instruction_table	signature:(typename T::opid_t type) const
dectype	instructions.h	/^        \/*API*\/ const type_t& dectype(typename T::tid_t type) const ;$/;"	p	class:ctb::instruction_table	access:public	signature:(typename T::tid_t type) const
dectype	instructions.h	/^    const typename instruction_table<T>::type_t& instruction_table<T>::dectype(typename T::tid_t type)   const$/;"	f	class:ctb::instruction_table	signature:(typename T::tid_t type) const
distances	instructions.h	/^          mutable graph_distance_t distances; \/\/technically taken just a cache$/;"	m	class:ctb::instruction_table::type	access:public
dummy	datatypes.h	/^      dummy(D...t){};$/;"	f	struct:ctb::dummy	access:public	signature:(D....t)
dummy	datatypes.h	/^  struct dummy$/;"	s	namespace:ctb
dummy_friend	datatypes.h	/^  struct dummy_friend$/;"	s	namespace:ctb
empty_tag	model.h	/^  struct empty_tag{};$/;"	s	namespace:ctb
env_in_$1	templates/bobox_decl_in.h	/^bobox::envelope_ptr_type env_in_$1;$/;"	v
env_out_$1	templates/bobox_decl_out.h	/^bobox::mutable_envelope_ptr_type env_out_$1;$/;"	v
environment	README.md	/^In order to specify a different output environment (e.g. different lanuage\/execution environment (such as bobox)), you will need to provide your custom descendant of the model class and to call the ctb::process with this class as a template parameter.$/;"	p	file:	signature:(e.g. different lanuage/execution environment (such as bobox))
export_graph	csvloader.h	/^        static void export_graph(IT& instab, std::ostream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::ostream&)
export_instab	csvloader.h	/^        static void export_instab(IT& instab, std::ostream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::ostream&)
fINPUT	datatypes.h	/^    fINPUT = 1, fOUTPUT = 2$/;"	e	enum:ctb::flags
fOUTPUT	datatypes.h	/^    fINPUT = 1, fOUTPUT = 2$/;"	e	enum:ctb::flags
fileexists	datatypes.h	/^  bool fileexists(char *name)$/;"	f	namespace:ctb	signature:(char *name)
files	split.sh	/^our @files = @ARGV;$/;"	v
flag_t	datatypes.h	/^    typedef int flag_t;$/;"	t	struct:ctb::traits	access:public
flags	csvloader.h	/^        static std::map<std::string, int> flags;$/;"	m	class:ctb::csv_loader	access:private
flags	datatypes.h	/^  enum flags $/;"	g	namespace:ctb
flags	instructions.h	/^            \/*EAPI*\/proxy<typename T::flag_t> flags;$/;"	m	class:ctb::instruction_table::operation	access:private
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
friend_maker	datatypes.h	/^    struct friend_maker$/;"	s	namespace:ctb
from_file	writer.h	/^        static std::string from_file(const std::string& filename);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename)
from_file	writer.h	/^    std::string writer<M>::from_file(const std::string& filename)$/;"	f	class:ctb::writer	signature:(const std::string& filename)
generate	generator.h	/^            template <class W> void generate(int granularity, W& w);$/;"	p	class:ctb::generator::data_t	access:public	signature:(int granularity, W& w)
generate	generator.h	/^        template <class W> void generate(int granularity, W& w) ;$/;"	p	class:ctb::generator	access:public	signature:(int granularity, W& w)
generate	generator.h	/^    void generator<T,IT>::data_t::generate(int granularity, W& w)$/;"	f	class:ctb::generator::data_t	signature:(int granularity, W& w)
generate	generator.h	/^    void generator<T,IT>::generate(int packsize, W& w)$/;"	f	class:ctb::generator	signature:(int packsize, W& w)
generate	model_bobox.h	/^      template <class G> static writer<model_bobox> generate(int m,  G& generator, std::string name);$/;"	p	class:ctb::model_bobox	access:public	signature:(int m, G& generator, std::string name)
generate	model_bobox.h	/^    writer<model_bobox> model_bobox::generate(int max_granularity, G& generator, std::string name)$/;"	f	class:ctb::model_bobox	signature:(int max_granularity, G& generator, std::string name)
generate	model_generator.h	/^      template <class G> static writer<model_generator> generate(int m,  G& graph, std::string name) ;$/;"	p	class:ctb::model_generator	access:public	signature:(int m, G& graph, std::string name)
generate	model_generator.h	/^    writer<model_generator> model_generator::generate(int max_granularity, G& graph, std::string name)$/;"	f	class:ctb::model_generator	signature:(int max_granularity, G& graph, std::string name)
generate	model_simple.h	/^      template <class G> static writer<model_simple> generate(int m,  G& generator, std::string name);$/;"	p	class:ctb::model_simple	access:public	signature:(int m, G& generator, std::string name)
generate	model_simple.h	/^    writer<model_simple> model_simple::generate(int granularity, G& generator, std::string name)$/;"	f	class:ctb::model_simple	signature:(int granularity, G& generator, std::string name)
generator	generator.h	/^        generator(const IT& i);$/;"	p	class:ctb::generator	access:public	signature:(const IT& i)
generator	generator.h	/^    class generator$/;"	c	namespace:ctb
generator	generator.h	/^    generator<T,IT>::generator(const IT & i) : instab(i), graph()$/;"	f	class:ctb::generator	signature:(const IT & i)
generator_default	generator.h	/^  typedef generator<traits, instruction_table_default> generator_default; $/;"	t	namespace:ctb
generator_t	ctb.h	/^        typedef generator<T,IT> generator_t;$/;"	t	class:ctb::ctb	access:private
get_acces	generator.h	/^            template <class W> writer<model_generator> get_acces(int width, int gran, W& w);$/;"	p	class:ctb::generator::data_t	access:private	signature:(int width, int gran, W& w)
get_acces	generator.h	/^    writer<model_generator> generator<T,IT>::data_t::get_acces(int width, int granularity, W& w)$/;"	f	class:ctb::generator::data_t	signature:(int width, int granularity, W& w)
get_broadest	generator.h	/^        int get_broadest(int upperbound = 10000000) ;$/;"	p	class:ctb::generator	access:public	signature:(int upperbound = 10000000)
get_broadest	generator.h	/^    int generator<T,IT>::get_broadest(int upperbound)$/;"	f	class:ctb::generator	signature:(int upperbound)
get_conv_string	instructions.h	/^            \/*API*\/bool get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string& type)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int from, int to, std::string& c1, std::string& c2, std::string& type) const
get_conv_string	instructions.h	/^    bool instruction_table<T>::operation::get_conv_string(int from, int to, std::string& c1, std::string& c2, std::string& t) const$/;"	f	class:ctb::instruction_table::operation	signature:(int from, int to, std::string& c1, std::string& c2, std::string& t) const
get_conversion_graph	instructions.h	/^            \/*API*\/const typename type::graph_distance_t& get_conversion_graph() const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:() const
get_conversion_graph	instructions.h	/^    const typename instruction_table<T>::type::graph_distance_t& instruction_table<T>::operation::get_conversion_graph() const$/;"	f	class:ctb::instruction_table::operation	signature:() const
get_dist	graph.h	/^        int get_dist(I a, I b, I* c = NULL) const;$/;"	p	class:ctb::graph_generic	access:public	signature:(I a, I b, I* c = NULL) const
get_dist	graph.h	/^    int graph_generic<T,I,directed,O...>::get_dist(I a, I b, I* c) const$/;"	f	class:ctb::graph_generic	signature:(I a, I b, I* c) const
get_inner_name	ctb.h	/^        std::string get_inner_name(std::string fname);$/;"	p	class:ctb::ctb	access:private	signature:(std::string fname)
get_inner_name	ctb.h	/^    std::string ctb<T,IT>::get_inner_name(std::string f)$/;"	f	class:ctb::ctb	signature:(std::string f)
get_inout_pos	generator.h	/^            int get_inout_pos() const;$/;"	p	class:ctb::generator::data_t	access:public	signature:() const
get_inout_pos	generator.h	/^    int generator<T,IT>::data_t::get_inout_pos() const$/;"	f	class:ctb::generator::data_t	signature:() const
get_max_width	instructions.h	/^            \/*API*\/int get_max_width(int bound = 1000000000, int* in = NULL, int* out = NULL)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int bound = 1000000000, int* in = NULL, int* out = NULL) const
get_max_width	instructions.h	/^    int instruction_table<T>::operation::get_max_width(int bound, int* in, int* out)const$/;"	f	class:ctb::instruction_table::operation	signature:(int bound, int* in, int* out) const
get_name	writer.h	/^        std::string get_name(const std::string& format, int& pos);$/;"	p	class:ctb::writer	access:private	signature:(const std::string& format, int& pos)
get_name	writer.h	/^    std::string writer<M>::get_name(const std::string& format, int& pos)$/;"	f	class:ctb::writer	signature:(const std::string& format, int& pos)
get_op_string	instructions.h	/^            \/*API*\/std::string get_op_string(int w = -1)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w = -1) const
get_op_string	instructions.h	/^    std::string instruction_table<T>::operation::get_op_string(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
get_path	graph.h	/^            node * get_path(node * n);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(node * n)
get_path	graph.h	/^    typename graph_generic<T,I,directed,O...>::node* graph_generic<T,I,directed,O...>::node::get_path(node * n)$/;"	f	class:ctb::graph_generic::node	signature:(node * n)
get_string	writer.h	/^        std::string get_string() const; \/\/does handle dolars internally!$/;"	p	class:ctb::writer	access:private	signature:() const
get_string	writer.h	/^    std::string writer<M>::get_string() const$/;"	f	class:ctb::writer	signature:() const
get_type_string	instructions.h	/^            \/*API*\/std::string get_type_string(int w = -1)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w = -1) const
get_type_string	instructions.h	/^    std::string instruction_table<T>::operation::get_type_string(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
getanystr	sort	/^std::string xml_loader<T,G,IT>::getanystr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
getanystr	xmlloader.h	/^        static std::string getanystr(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
getanystr	xmlloader.h	/^    std::string xml_loader<T,G,IT>::getanystr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
getint	xmlloader.h	/^        static int getint(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
getint	xmlloader.h	/^    int xml_loader<T,G,IT>::getint(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
getnth	writer.h	/^        template <typename ... Types> const writer<M>& getnth(int i, const writer<M>& a, const Types&... params);$/;"	p	class:ctb::writer	access:private	signature:(int i, const writer<M>& a, const Types&... params)
getnth	writer.h	/^        writer<M> getnth(int i);$/;"	p	class:ctb::writer	access:private	signature:(int i)
getnth	writer.h	/^    template <typename ... Types> const writer<M>& writer<M>::getnth(int i, const writer<M>& a, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const writer<M>& a, const Types&... params)
getnth	writer.h	/^    writer<M> writer<M>::getnth(int i)$/;"	f	class:ctb::writer	signature:(int i)
getstr	xmlloader.h	/^        static std::string getstr(tinyxml2::XMLNode * node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode * node, std::string name)
getstr	xmlloader.h	/^    std::string xml_loader<T,G,IT>::getstr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
graph	README.md	/^The default project accepts a xml representation of an instruction table (which describes the conversion of instructions) and of a graph, which uses opcodes defined by the instruction table, and produces a simple c++ test unit.$/;"	v
graph	generator.h	/^        proxy<graph_t> graph;$/;"	m	class:ctb::generator	access:public
graph_default	graph.h	/^  typedef graph_generic<dummy,int,true> graph_default;$/;"	t	namespace:ctb
graph_distance_t	instructions.h	/^          typedef graph_generic<dummy, int, false, type> graph_distance_t;$/;"	t	class:ctb::instruction_table::type	access:public
graph_generic	graph.h	/^        graph_generic();$/;"	p	class:ctb::graph_generic	access:public	signature:()
graph_generic	graph.h	/^    class graph_generic$/;"	c	namespace:ctb
graph_generic	graph.h	/^    graph_generic<T,I,directed,O...>::graph_generic() : in(), out(), verts(), index(0)$/;"	f	class:ctb::graph_generic	signature:()
graph_t	generator.h	/^        typedef graph_generic<data_t, typename T::vid_t, true, generator> graph_t;$/;"	t	class:ctb::generator	access:private
hasval	xmlloader.h	/^        static bool hasval(tinyxml2::XMLNode* node, std::string name);$/;"	p	class:ctb::xml_loader	access:private	signature:(tinyxml2::XMLNode* node, std::string name)
hasval	xmlloader.h	/^    bool xml_loader<T,G,IT>::hasval(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:ctb::xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
help	ctb.h	/^        void help();$/;"	p	class:ctb::ctb	access:private	signature:()
help	ctb.h	/^    void ctb<T,IT>::help()$/;"	f	class:ctb::ctb	signature:()
id	graph.h	/^            proxy<I> id;$/;"	m	class:ctb::graph_generic::node	access:public
id_t	generator.h	/^        typedef typename T::opid_t id_t;$/;"	t	class:ctb::generator	access:private
imbue_width	instructions.h	/^            \/*API*\/void imbue_width(int w)const;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(int w) const
imbue_width	instructions.h	/^    void instruction_table<T>::operation::imbue_width(int w)const$/;"	f	class:ctb::instruction_table::operation	signature:(int w) const
imbued_width	instructions.h	/^            mutable int imbued_width;$/;"	m	class:ctb::instruction_table::operation	access:private
in	graph.h	/^            proxy<std::vector<node*> > in;$/;"	m	class:ctb::graph_generic::node	access:public
index	graph.h	/^            int index;$/;"	m	class:ctb::graph_generic::node	access:private
index	graph.h	/^        int index;$/;"	m	class:ctb::graph_generic	access:private
init	model.h	/^      static void init();$/;"	p	class:ctb::model_maker	access:protected	signature:()
init	model.h	/^  void model_maker<T,L>::init()$/;"	f	class:ctb::model_maker	signature:()
init	model_bobox.h	/^      static void init();$/;"	p	class:ctb::model_bobox	access:protected	signature:()
init	model_bobox.h	/^  void model_bobox::init()$/;"	f	class:ctb::model_bobox	signature:()
init	model_generator.h	/^      static void init();$/;"	p	class:ctb::model_generator	access:protected	signature:()
init	model_generator.h	/^  void model_generator::init()$/;"	f	class:ctb::model_generator	signature:()
init	model_simple.h	/^      static void init();$/;"	p	class:ctb::model_simple	access:protected	signature:()
init	model_simple.h	/^  void model_simple::init()$/;"	f	class:ctb::model_simple	signature:()
init_map	graph.h	/^            bool init_map(int size);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(int size)
init_map	graph.h	/^    bool graph_generic<T,I,directed,O...>::node::init_map(int size)$/;"	f	class:ctb::graph_generic::node	signature:(int size)
insert	csvloader.h	/^        static void insert(IT& instab, std::string line);$/;"	p	class:ctb::csv_loader	access:private	signature:(IT& instab, std::string line)
insert	csvloader.h	/^    void csv_loader<T,G,IT,D>::insert(IT& instab, std::string line)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::string line)
instab	ctb.h	/^        IT instab;$/;"	m	class:ctb::ctb	access:private
instab	generator.h	/^        proxy<const IT&> instab;$/;"	m	class:ctb::generator	access:public
instab	instructions.h	/^        \/*EAPI*\/proxy<instab_t> instab;$/;"	m	class:ctb::instruction_table	access:public
instab_t	instructions.h	/^        typedef std::map<typename T::opid_t, operation*> instab_t;$/;"	t	class:ctb::instruction_table	access:private
instruction	instructions.h	/^              instruction(int wi, int wo, const std::string& c);$/;"	p	struct:ctb::instruction_table::operation::instruction	access:public	signature:(int wi, int wo, const std::string& c)
instruction	instructions.h	/^            struct instruction \/\/holds information for generation$/;"	s	class:ctb::instruction_table::operation	access:private
instruction	instructions.h	/^    instruction_table<T>::operation::instruction::instruction(int wi, int wo, const std::string& c) : code(c), width_in(wi), width_out(wo), width(std::max(wi, wo))$/;"	f	class:ctb::instruction_table::operation::instruction	signature:(int wi, int wo, const std::string& c)
instruction_table	instructions.h	/^    class instruction_table \/\/provides transition from opcode to abstract operation$/;"	c	namespace:ctb
instruction_table_default	instructions.h	/^  typedef instruction_table<traits> instruction_table_default;$/;"	t	namespace:ctb
is	instructions.h	/^            \/*API*\/bool is(typename T::flag_t f) const ;$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(typename T::flag_t f) const
is	instructions.h	/^    bool instruction_table<T>::operation::is(typename T::flag_t f) const $/;"	f	class:ctb::instruction_table::operation	signature:(typename T::flag_t f) const
language	model.h	/^      typedef L language;$/;"	t	class:ctb::model_maker	access:public
language	model_bobox.h	/^      typedef language_cpp language;$/;"	t	class:ctb::model_bobox	access:public
language	model_generator.h	/^      typedef language_empty language;$/;"	t	class:ctb::model_generator	access:public
language	model_simple.h	/^      typedef language_cpp language;$/;"	t	class:ctb::model_simple	access:public
language_cpp	languages.h	/^    class language_cpp$/;"	c	namespace:ctb
language_empty	languages.h	/^    class language_empty$/;"	c	namespace:ctb
last_terminated	writer.h	/^        bool last_terminated;$/;"	m	class:ctb::writer	access:private
lastpass	graph.h	/^            int lastpass;$/;"	m	class:ctb::graph_generic::node	access:private
list_concat	writer.h	/^        writer& list_concat(const std::string& delim);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& delim)
list_concat	writer.h	/^    writer<M> &writer<M>::list_concat(const std::string& delim)$/;"	f	class:ctb::writer	signature:(const std::string& delim)
load_graph	csvloader.h	/^        static void load_graph(G& graph, std::istream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(G& graph, std::istream&)
load_graph	csvloader.h	/^    void csv_loader<T,G,IT,D>::load_graph(G& graph, std::istream&)$/;"	f	class:ctb::csv_loader	signature:(G& graph, std::istream&)
load_graph	xmlloader.h	/^        static void load_graph(G& graph, std::string filename) ;$/;"	p	class:ctb::xml_loader	access:public	signature:(G& graph, std::string filename)
load_graph	xmlloader.h	/^    void xml_loader<T,G,IT>::load_graph(G& graph, std::string filename)$/;"	f	class:ctb::xml_loader	signature:(G& graph, std::string filename)
load_instab	csvloader.h	/^        static void load_instab(IT& instab, std::istream&) ;$/;"	p	class:ctb::csv_loader	access:public	signature:(IT& instab, std::istream&)
load_instab	csvloader.h	/^    void csv_loader<T,G,IT,D>::load_instab(IT& instab, std::istream& s)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::istream& s)
load_instab	ctb.h	/^        template<template <typename Q, typename QQ, typename QQQ> class L, typename...P> void load_instab(P...params) ;$/;"	p	class:ctb::ctb	access:public	signature:(P....params)
load_instab	ctb.h	/^    template<template <typename Q, typename QQ, typename QQQ> class L, typename...P> void ctb<T,IT>::load_instab(P...params)$/;"	f	class:ctb::ctb	signature:(P....params)
load_instab	xmlloader.h	/^        static void load_instab(IT& instab, std::string filename) ;$/;"	p	class:ctb::xml_loader	access:public	signature:(IT& instab, std::string filename)
load_instab	xmlloader.h	/^    void xml_loader<T,G,IT>::load_instab(IT& instab, std::string filename)$/;"	f	class:ctb::xml_loader	signature:(IT& instab, std::string filename)
loader_default	xmlloader.h	/^  typedef xml_loader<traits, generator_default, instruction_table_default> loader_default;$/;"	t	namespace:ctb
main	main.cpp	/^int main(int count, char**args)$/;"	f	signature:(int count, char**args)
main	output/test_simple.cpp	/^int main()$/;"	f	signature:()
main	test.cpp	/^int main()$/;"	f	signature:()
map	graph.h	/^            mutable std::vector<route> map;$/;"	m	class:ctb::graph_generic::node	access:private
maxarity	datatypes.h	/^    static const int maxarity = 3;$/;"	m	struct:ctb::traits	access:public
me	generator.h	/^            node_t* me;$/;"	m	class:ctb::generator::data_t	access:private
model	templates/bobox_box.h	/^  typedef generic_model<$1_box> model;$/;"	t	class:$1_box	access:public
model_bobox	model_bobox.h	/^  class model_bobox : public model_generator$/;"	c	namespace:ctb	inherits:model_generator
model_bobox	tags	/^ctb::model_bobox	model_bobox.h	\/^  class model_bobox : public model_generator$\/;"	c	namespace:ctb	inherits:model_generator$/;"	c	file:	inherits:model_generator$,t,:ctb::model_boboxaccess:,ctb::model_bobox::aliastab_tmodel_bobox,h,std::mapaliastab_t,$,m,:ctb::model_boboxaccess:,ctb::model_bobox::aliasesmodel_bobox,h,aliastab_taliases,$,p,:ctb::model_boboxaccess:,signature:,ctb::model_bobox::initmodel_bobox,h,init,$,t,:ctb::model_boboxaccess:,ctb::model_bobox::languagemodel_bobox,h,language_cpplanguage,$,p,:ctb::model_boboxaccess:,signature:,std::string,a,ctb::model_bobox::aliasmodel_bobox,h,std::stringalias,std::string,a,$,p,:ctb::model_boboxaccess:,signature:,m,G,generator,std::stringname,ctb::model_bobox::generatemodel_bobox,h,writergenerate,m,G,generator,std::stringname,$,m,:ctb::model_boboxctb::model_bobox::aliasesmodel_bobox,h,std::mapmodel_bobox::aliases,$,daliasmodel_bobox,h,std::stringmodel_bobox::alias,std::string,a,$,f,:ctb::model_boboxsignature:,std::string,a,initmodel_bobox,h,model_bobox::init,$,f,:ctb::model_boboxsignature:,generatemodel_bobox,h,writermodel_bobox::generate,max_granularity,G,generator,std::stringname,$,f,:ctb::model_boboxsignature:,max_granularity,G,generator,std::stringname,MODEL_GENERATOR_GUARDmodel_generator,h,nmodel_generatormodel_generator,h,model_generator$,c,:ctbaliastab_tmodel_generator,h,std::mapaliastab_t,$,t,:ctb::model_generatoraccess:,aliasesmodel_generator,h,aliastab_taliases,$,m,:ctb::model_generatoraccess:,initmodel_generator,h,init,$,p,:ctb::model_generatoraccess:,signature:,languagemodel_generator,h,language_emptylanguage,$,t,:ctb::model_generatoraccess:,aliasmodel_generator,h,std::stringalias,std::string,a,$,p,:ctb::model_generatoraccess:,signature:,std::string,a,generatemodel_generator,h,writergenerate,m,G,graph,std::stringname,$,p,:ctb::model_generatoraccess:,signature:,m,G,graph,std::stringname,aliasesmodel_generator,h,std::mapmodel_generator::aliases,$,m,:ctb::model_generatorADDmodel_generator,h,f,:ctb::model_generatorsignature:,std::string,a,ctb::model_generator::aliasmodel_generator,h,std::stringmodel_generator::alias,std::string,a,$,f,:ctb::model_generatorsignature:,ctb::model_generator::initmodel_generator,h,model_generator::init,$,f,:ctb::model_generatorsignature:,max_granularity,G,graph,std::stringname,ctb::model_generator::generatemodel_generator,h,writermodel_generator::generate,max_granularity,G,graph,std::stringname,$,vMODEL_GUARDmodel,h,nmodel_makermodel,h,model_maker$,c,:ctbaliastab_tmodel,h,std::mapaliastab_t,$,t,:ctb::model_makeraccess:,aliasesmodel,h,aliastab_taliases,$,m,:ctb::model_makeraccess:,initmodel,h,init,$,p,:ctb::model_makeraccess:,signature:,languagemodel,h,Llanguage,$,t,:ctb::model_makeraccess:,aliasmodel,h,std::stringalias,std::string,a,$,p,:ctb::model_makeraccess:,signature:,std::string,a,clearmodel,h,clear,$,p,:ctb::model_makeraccess:,signature:,accessmodel,h,std::string,access,std::string,$,p,:ctb::model_makeraccess:,signature:,std::string,empty_tagmodel,h,empty_tag
model_empty	model.h	/^  typedef model_maker<empty_tag, language_empty> model_empty;$/;"	t	namespace:ctb
model_empty	tags	/^model_empty	model.h	\/^  typedef model_maker<empty_tag, language_empty> model_empty;$\/;"	t	namespace:ctb$/;"	t	file:
model_empty_cpp	model.h	/^  typedef model_maker<empty_tag, language_cpp> model_empty_cpp;$/;"	t	namespace:ctb
model_empty_cpp	tags	/^model_empty_cpp	model.h	\/^  typedef model_maker<empty_tag, language_cpp> model_empty_cpp;$\/;"	t	namespace:ctb$/;"	t	file:
model_generator	model_generator.h	/^  class model_generator $/;"	c	namespace:ctb
model_maker	model.h	/^  class model_maker$/;"	c	namespace:ctb
model_pre	csvloader.h	/^        typedef model_maker<csv_loader_tag, language_empty> model_pre;$/;"	t	class:ctb::csv_loader	access:private
model_simple	model_simple.h	/^  class model_simple : public model_generator$/;"	c	namespace:ctb	inherits:model_generator
mytype	instructions.h	/^            \/*EAPI*\/proxy<type*> mytype;$/;"	m	class:ctb::instruction_table::operation	access:private
newid	graph.h	/^            int newid();$/;"	p	class:ctb::graph_generic::node	access:private	signature:()
newid	graph.h	/^    int graph_generic<T,I,directed,O...>::node::newid()$/;"	f	class:ctb::graph_generic::node	signature:()
newname	generator.h	/^            std::string newname(std::string tag) ;$/;"	p	class:ctb::generator::data_t	access:private	signature:(std::string tag)
newname	generator.h	/^    std::string generator<T,IT>::data_t::newname(std::string tag)$/;"	f	class:ctb::generator::data_t	signature:(std::string tag)
node	graph.h	/^            template <typename... L> node(I vid, int index, L&&... p);$/;"	p	class:ctb::graph_generic::node	access:private	signature:(I vid, int index, L&&... p)
node	graph.h	/^        class node$/;"	c	class:ctb::graph_generic	access:private
node	graph.h	/^    graph_generic<T,I,directed,O...>::node::node(I vid, int idx, L&&... p) : id(vid), out(), in(), data(this, (std::forward<L>(p))...), index(idx)$/;"	f	class:ctb::graph_generic::node	signature:(I vid, int idx, L&&... p)
node_t	generator.h	/^        typedef typename graph_t::node_t node_t;$/;"	t	class:ctb::generator	access:private
node_t	graph.h	/^        typedef node node_t;$/;"	t	class:ctb::graph_generic	access:public
op_t	generator.h	/^        typedef typename IT::operation_t op_t;$/;"	t	class:ctb::generator	access:private
operation	instructions.h	/^            operation(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t);$/;"	p	class:ctb::instruction_table::operation	access:public	signature:(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t)
operation	instructions.h	/^        class operation \/\/holds general operation traits$/;"	c	class:ctb::instruction_table	access:private
operation	instructions.h	/^    instruction_table<T>::operation::operation(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t) : opid(i), mytype(t), out_type(ot), flags(f)$/;"	f	class:ctb::instruction_table::operation	signature:(typename T::opid_t i, typename T::tid_t ot, typename T::flag_t f, type* t)
operation_t	instructions.h	/^        typedef operation operation_t; $/;"	t	class:ctb::instruction_table	access:public
operator !=	writer.h	/^        bool operator!=(const writer& w) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& w)
operator !=	writer.h	/^    bool writer<M>::operator!=(const writer& w)$/;"	f	class:ctb::writer	signature:(const writer& w)
operator *	datatypes.h	/^      const T& operator*() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
operator ->	datatypes.h	/^      const result_t* operator->() const { return &data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
operator ->	graph.h	/^            proxy<T,O...>& operator->();$/;"	p	class:ctb::graph_generic::node	access:public	signature:()
operator ->	graph.h	/^    graph_generic<T,I,directed,O...>::node::proxy<T,O...>& graph_generic<T,I,directed,O...>::node::operator->()  $/;"	f	class:ctb::graph_generic::node	signature:()
operator =	writer.h	/^        template<typename N> writer& operator=( const writer<N>& w) ;$/;"	p	class:ctb::writer	access:public	signature:( const writer<N>& w)
operator =	writer.h	/^        template<typename N> writer& operator=( writer<N>&& w) ;$/;"	p	class:ctb::writer	access:public	signature:( writer<N>&& w)
operator =	writer.h	/^    writer<M>& writer<M>::operator=(const writer<N>& w)$/;"	f	class:ctb::writer	signature:(const writer<N>& w)
operator =	writer.h	/^    writer<M>& writer<M>::operator=(writer<N>&& w)$/;"	f	class:ctb::writer	signature:(writer<N>&& w)
operator ==	writer.h	/^        bool operator==(const writer& w) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& w)
operator ==	writer.h	/^    bool writer<M>::operator==(const writer& w)$/;"	f	class:ctb::writer	signature:(const writer& w)
operator []	datatypes.h	/^      template <typename U> typename br_ct<U>::type operator [](U args) const { return data[args]; }$/;"	f	class:ctb::proxy_	access:public	signature:(U args) const
operator const T&	datatypes.h	/^      operator const T&() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
opid	generator.h	/^            proxy<id_t> opid;$/;"	m	class:ctb::generator::data_t	access:public
opid	instructions.h	/^            \/*EAPI*\/proxy<typename T::opid_t> opid;$/;"	m	class:ctb::instruction_table::operation	access:private
opid_t	datatypes.h	/^    typedef std::string opid_t;$/;"	t	struct:ctb::traits	access:public
out	graph.h	/^            proxy<std::vector<node*> > out;$/;"	m	class:ctb::graph_generic::node	access:public
out	graph.h	/^        proxy<vertex_list_t> out;$/;"	m	class:ctb::graph_generic	access:public
out_type	instructions.h	/^            \/*EAPI*\/proxy<typename T::tid_t> out_type;$/;"	m	class:ctb::instruction_table::operation	access:private
output_list_$1	templates/bobox_send.h	/^send_poisoned( outputs::output_list_$1());$/;"	p	signature:()
param_t	datatypes.h	/^    typedef int param_t;$/;"	t	struct:ctb::traits	access:public
param_t	generator.h	/^        typedef typename T::param_t param_t;$/;"	t	class:ctb::generator	access:private
parameters	generator.h	/^            std::vector<param_t> parameters;$/;"	m	class:ctb::generator::data_t	access:private
parent	graph.h	/^            graph_generic* parent;$/;"	m	class:ctb::graph_generic::node	access:private
pass	datatypes.h	/^  template <typename ... T> void pass(T...)$/;"	f	namespace:ctb	signature:(T....)
pos_in_$1	templates/bobox_decl_in.h	/^unsigned pos_in_$1 = 0;$/;"	v
pos_in_$1	templates/simple_decl_in.h	/^unsigned pos_in_$1 = 0;$/;"	v
pos_out_$1	templates/bobox_decl_out.h	/^unsigned pos_out_$1 = 0;$/;"	v
pos_out_$1	templates/simple_decl_out.h	/^unsigned pos_out_$1 = 0;$/;"	v
preprocessline	csvloader.h	/^        static std::vector<std::string> preprocessline(std::string line);$/;"	p	class:ctb::csv_loader	access:private	signature:(std::string line)
preprocessline	csvloader.h	/^    std::vector<std::string> csv_loader<T,G,IT,D>::preprocessline(std::string line)$/;"	f	class:ctb::csv_loader	signature:(std::string line)
preprocessor	csvloader.h	/^        typedef writer<model_pre> preprocessor;$/;"	t	class:ctb::csv_loader	access:private
print	model.h	/^  template<bool dolars = false, typename ... Types> std::string print (const Types&... params)$/;"	f	namespace:ctb	signature:(const Types&.... params)
print	writer.h	/^        template<bool dolars = false, typename ... Types> writer& print (const std::string& format, const Types&... params) ; \/**should accept at least string and another writer class e.g. print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j*\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& format, const Types&... params)
print	writer.h	/^        template<bool dolars = false, typename ... Types> writer& print (const writer& format, const Types&... params) ;$/;"	p	class:ctb::writer	access:public	signature:(const writer& format, const Types&... params)
print	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print(const std::string& format, const Types&... params)  \/\/print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	f	class:ctb::writer	signature:(const std::string& format, const Types&... params)
print	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print(const writer& format, const Types&... params)$/;"	f	class:ctb::writer	signature:(const writer& format, const Types&... params)
print_internal	writer.h	/^        template<bool dolars, typename ... Types> writer& print_internal (const std::string& format, const Types&... params) ; \/\/should accept at least string and another writer class e.g. print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	p	class:ctb::writer	access:private	signature:(const std::string& format, const Types&... params)
print_internal	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::print_internal(const std::string& format, const Types&... params)  \/\/print("a[$1] = a[$1] $ $2", i, j) -> "a[i] = a[i] $ j$/;"	f	class:ctb::writer	signature:(const std::string& format, const Types&... params)
printf	writer.h	/^        template<bool dolars = false, typename ... Types> writer& printf(const std::string& filename, const Types&... params) ; \/** print, but the first argument is a filename of a file which is to be loaded instead of the format string *\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const Types&... params)
printf	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::printf(const std::string& filename, const Types&... params)$/;"	f	class:ctb::writer	signature:(const std::string& filename, const Types&... params)
printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const int& num, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const int& num, const Types&... params)
printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const std::string& str, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const std::string& str, const Types&... params)
printnth	writer.h	/^        template <typename ... Types> void printnth(int i, const writer& wrt, const Types&... params) ;$/;"	p	class:ctb::writer	access:private	signature:(int i, const writer& wrt, const Types&... params)
printnth	writer.h	/^        void printnth(int i);$/;"	p	class:ctb::writer	access:private	signature:(int i)
printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const int& num, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const int& num, const Types&... params)
printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const std::string& str, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const std::string& str, const Types&... params)
printnth	writer.h	/^    template <typename ... Types> void writer<M>::printnth(int i, const writer& wrt, const Types&... params)$/;"	f	class:ctb::writer	signature:(int i, const writer& wrt, const Types&... params)
printnth	writer.h	/^    void writer<M>::printnth(int i)$/;"	f	class:ctb::writer	signature:(int i)
process	csvloader.h	/^        static void process(IT& instab, std::istream& s);$/;"	p	class:ctb::csv_loader	access:private	signature:(IT& instab, std::istream& s)
process	csvloader.h	/^    void csv_loader<T,G,IT,D>::process(IT& instab, std::istream& s)$/;"	f	class:ctb::csv_loader	signature:(IT& instab, std::istream& s)
process	ctb.h	/^        template<template <typename Q, typename QQ, typename QQQ> class L, typename M, typename...P> std::string process(std::string name, P...params) ;$/;"	p	class:ctb::ctb	access:public	signature:(std::string name, P...params)
process	ctb.h	/^    std::string ctb<T,IT>::process(std::string name, P...params)$/;"	f	class:ctb::ctb	signature:(std::string name, P...params)
process	writer.h	/^        void process(int& pos, const std::string& format) ;$/;"	p	class:ctb::writer	access:private	signature:(int& pos, const std::string& format)
process	writer.h	/^    void writer<M>::process(int& pos, const std::string& format)$/;"	f	class:ctb::writer	signature:(int& pos, const std::string& format)
processed_in_$1	templates/simple_decl_in.h	/^unsigned processed_in_$1 = 0;$/;"	v
processed_out_$1	templates/simple_decl_out.h	/^unsigned processed_out_$1 = 0;$/;"	v
proxy_	datatypes.h	/^      template <typename...L> proxy_(L&&... args) : data((std::forward<L>(args))...){}$/;"	f	class:ctb::proxy_	access:public	signature:(L&&.... args)
proxy_	datatypes.h	/^    class proxy_ {$/;"	c	namespace:ctb
push	writer.h	/^        template<bool dolars = false, typename ... Types, typename Type> writer& push  (const Type& format, const Types&... params) ; \/** explicit push on a new line. To be used with list_concat for simple creation of delimited lists.*\/$/;"	p	class:ctb::writer	access:public	signature:(const Type& format, const Types&... params)
push	writer.h	/^    template<bool dolars , typename ... Types, typename Type> writer<M>& writer<M>::push(const Type& format, const Types&... params)$/;"	f	class:ctb::writer	signature:(const Type& format, const Types&... params)
push_params	generator.h	/^            template<typename P, typename...Ps> void push_params(P&&, Ps&&... params);$/;"	p	class:ctb::generator::data_t	access:private	signature:(P&&, Ps&&... params)
push_params	generator.h	/^            void push_params();$/;"	p	class:ctb::generator::data_t	access:private	signature:()
push_params	generator.h	/^    void generator<T,IT>::data_t::push_params()$/;"	f	class:ctb::generator::data_t	signature:()
push_params	generator.h	/^    void generator<T,IT>::data_t::push_params(P&& p, Ps&&...params)$/;"	f	class:ctb::generator::data_t	signature:(P&& p, Ps&&...params)
pushf	writer.h	/^        template<bool dolars = false, typename ... Types> writer& pushf (const std::string& filename, const Types&... params) ; \/** pushf is again a file-loaded version of push *\/$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const Types&... params)
pushf	writer.h	/^    template<bool dolars, typename ... Types> writer<M>& writer<M>::pushf(const std::string& filename, const Types&... params)$/;"	f	class:ctb::writer	signature:(const std::string& filename, const Types&... params)
r	datatypes.h	/^      const result_t& r() const { return data; }$/;"	f	class:ctb::proxy_	access:public	signature:() const
result_t	datatypes.h	/^      typedef typename std::remove_reference<T>::type result_t;$/;"	t	class:ctb::proxy_	access:private
route	graph.h	/^            typedef std::pair<node*, int> route;$/;"	t	class:ctb::graph_generic::node	access:private
rw	datatypes.h	/^      result_t& rw() { return data; }$/;"	f	class:ctb::proxy_	access:private	signature:()
self_test	csvloader.h	/^        static void self_test() ;$/;"	p	class:ctb::csv_loader	access:public	signature:()
self_test	csvloader.h	/^    void csv_loader<T,G,IT,D>::self_test()$/;"	f	class:ctb::csv_loader	signature:()
self_test	ctb.h	/^        static void self_test() ;$/;"	p	class:ctb::ctb	access:public	signature:()
self_test	ctb.h	/^    void ctb<T,IT>::self_test()$/;"	f	class:ctb::ctb	signature:()
self_test	graph.h	/^        static void self_test();$/;"	p	class:ctb::graph_generic	access:public	signature:()
self_test	graph.h	/^    void graph_generic<T,I,directed,O...>::self_test()$/;"	f	class:ctb::graph_generic	signature:()
self_test	writer.h	/^        static void self_test() ;$/;"	p	class:ctb::writer	access:public	signature:()
self_test	writer.h	/^    void writer<M>::self_test()$/;"	f	class:ctb::writer	signature:()
self_test	xmlloader.h	/^        static void self_test() ;$/;"	p	class:ctb::xml_loader	access:public	signature:()
self_test	xmlloader.h	/^    void xml_loader<T,G,IT>::self_test()$/;"	f	class:ctb::xml_loader	signature:()
shake	csvloader.h	/^        template <typename I> static void shake(I itr, I itre, std::string line, std::vector<std::string>& output);$/;"	p	class:ctb::csv_loader	access:private	signature:(I itr, I itre, std::string line, std::vector<std::string>& output)
shake	csvloader.h	/^    void csv_loader<T,G,IT,D>::shake(I itr, I itre, std::string line, std::vector<std::string>& output)$/;"	f	class:ctb::csv_loader	signature:(I itr, I itre, std::string line, std::vector<std::string>& output)
shouldbreak	languages.h	/^        static void shouldbreak(const int& pos, const std::string& format, bool& brbf, bool& braf)$/;"	f	class:ctb::language_cpp	access:public	signature:(const int& pos, const std::string& format, bool& brbf, bool& braf)
shouldbreak	languages.h	/^        static void shouldbreak(const int& pos, const std::string&, bool& brbf, bool& braf)$/;"	f	class:ctb::language_empty	access:public	signature:(const int& pos, const std::string&, bool& brbf, bool& braf)
shouldindent	languages.h	/^        static void shouldindent( const std::string& line, int& outindent, int& indent, int& nobreak)$/;"	f	class:ctb::language_cpp	access:public	signature:( const std::string& line, int& outindent, int& indent, int& nobreak)
shouldindent	languages.h	/^        static void shouldindent( const std::string&, int& outindent, int& indent, int& nobreak)$/;"	f	class:ctb::language_empty	access:public	signature:( const std::string&, int& outindent, int& indent, int& nobreak)
size_in_$1	templates/bobox_decl_in.h	/^unsigned size_in_$1 = 0;$/;"	v
size_in_$1	templates/simple_decl_in.h	/^unsigned size_in_$1 = 0;$/;"	v
size_out_$1	templates/bobox_decl_out.h	/^unsigned size_out_$1 = 0;$/;"	v
size_out_$1	templates/simple_decl_out.h	/^unsigned size_out_$1 = 0;$/;"	v
split	csvloader.h	/^        static std::vector<std::string> split(std::string str, char d);$/;"	p	class:ctb::csv_loader	access:private	signature:(std::string str, char d)
split	csvloader.h	/^    std::vector<std::string> csv_loader<T,G,IT,D>::split(std::string str, char d)$/;"	f	class:ctb::csv_loader	signature:(std::string str, char d)
stoi	datatypes.h	/^  int stoi(std::string str)$/;"	f	namespace:ctb	signature:(std::string str)
stringlist	datatypes.h	/^  typedef std::vector<std::string> stringlist;$/;"	t	namespace:ctb
table	README.md	/^The default project accepts a xml representation of an instruction table (which describes the conversion of instructions) and of a graph, which uses opcodes defined by the instruction table, and produces a simple c++ test unit.$/;"	v
test_body	output-manual/graph.h	/^void test_body()$/;"	f	signature:()
test_body	output/test_simple.h	/^void test_body()$/;"	f	signature:()
test_body	templates/simple_box.h	/^void test_body() $/;"	f	signature:()
tid_t	datatypes.h	/^    typedef std::string tid_t;$/;"	t	struct:ctb::traits	access:public
to_file	writer.h	/^        static void to_file(const std::string& filename, const std::string& contents);$/;"	p	class:ctb::writer	access:public	signature:(const std::string& filename, const std::string& contents)
to_file	writer.h	/^    void writer<M>::to_file(const std::string& filename,const std::string& contents)$/;"	f	class:ctb::writer	signature:(const std::string& filename,const std::string& contents)
to_writer	writer.h	/^        const writer<M>& to_writer(const writer<M>& r);$/;"	p	class:ctb::writer	access:private	signature:(const writer<M>& r)
to_writer	writer.h	/^        writer<M> to_writer(const int& r);$/;"	p	class:ctb::writer	access:private	signature:(const int& r)
to_writer	writer.h	/^        writer<M> to_writer(const std::string& r);$/;"	p	class:ctb::writer	access:private	signature:(const std::string& r)
to_writer	writer.h	/^    const writer<M>& writer<M>::to_writer(const writer<M>& r)$/;"	f	class:ctb::writer	signature:(const writer<M>& r)
to_writer	writer.h	/^    writer<M> writer<M>::to_writer(const int& r)$/;"	f	class:ctb::writer	signature:(const int& r)
to_writer	writer.h	/^    writer<M> writer<M>::to_writer(const std::string& r)$/;"	f	class:ctb::writer	signature:(const std::string& r)
traits	datatypes.h	/^  struct traits$/;"	s	namespace:ctb
trim	writer.h	/^        void trim() ;$/;"	p	class:ctb::writer	access:private	signature:()
trim	writer.h	/^    void writer<M>::trim()$/;"	f	class:ctb::writer	signature:()
type	datatypes.h	/^      template <typename U> struct br_ct  { typedef decltype(std::declval<T const>()[std::declval<U>()]) type; };$/;"	t	struct:ctb::proxy_::br_ct	access:public
type	datatypes.h	/^      template <typename U> struct br_t { typedef decltype(std::declval<T      >()[std::declval<U>()]) type; };$/;"	t	struct:ctb::proxy_::br_t	access:public
type	datatypes.h	/^      typedef T type;$/;"	t	struct:ctb::friend_maker	access:public
type	instructions.h	/^        class type$/;"	c	class:ctb::instruction_table	access:private
type_t	instructions.h	/^        typedef type type_t; $/;"	t	class:ctb::instruction_table	access:public
type_version	instructions.h	/^            type_version(int w, const std::string& c);$/;"	p	struct:ctb::instruction_table::type::type_version	access:public	signature:(int w, const std::string& c)
type_version	instructions.h	/^          struct type_version$/;"	s	class:ctb::instruction_table::type	access:public
type_version	instructions.h	/^    instruction_table<T>::type::type_version::type_version(int w, const std::string& c) : width(w), code(c)$/;"	f	class:ctb::instruction_table::type::type_version	signature:(int w, const std::string& c)
typetab	instructions.h	/^        \/*EAPI*\/proxy<typetable_t> typetab;$/;"	m	class:ctb::instruction_table	access:public
typetable_t	instructions.h	/^        typedef std::map<typename T::tid_t, type*> typetable_t;$/;"	t	class:ctb::instruction_table	access:private
update_distances	graph.h	/^            bool update_distances();$/;"	p	class:ctb::graph_generic::node	access:private	signature:()
update_distances	graph.h	/^    bool graph_generic<T,I,directed,O...>::node::update_distances()$/;"	f	class:ctb::graph_generic::node	signature:()
versions	instructions.h	/^            \/*EAPI*\/proxy<std::vector<instruction>> versions;$/;"	m	class:ctb::instruction_table::operation	access:private
versions	instructions.h	/^          \/*EAPI*\/proxy<std::vector<type_version>> versions;$/;"	m	class:ctb::instruction_table::type	access:public
vertex_container_t	graph.h	/^        typedef std::map<I, node*> vertex_container_t;$/;"	t	class:ctb::graph_generic	access:private
vertex_list_t	graph.h	/^        typedef std::vector<node*> vertex_list_t;$/;"	t	class:ctb::graph_generic	access:private
verts	graph.h	/^        proxy<vertex_container_t> verts;$/;"	m	class:ctb::graph_generic	access:public
vid_t	datatypes.h	/^    typedef std::string vid_t;$/;"	t	struct:ctb::traits	access:public
vid_t	generator.h	/^        typedef typename T::vid_t vid_t;$/;"	t	class:ctb::generator	access:private
width	instructions.h	/^              int width;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
width	instructions.h	/^            const int width;$/;"	m	struct:ctb::instruction_table::type::type_version	access:public
width_in	instructions.h	/^              int width_in;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
width_in	instructions.h	/^            const int width_in;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
width_out	instructions.h	/^              int width_out;$/;"	m	struct:ctb::instruction_table::operation::instruction	access:public
width_out	instructions.h	/^            const int width_out;$/;"	m	struct:ctb::instruction_table::type::conversion	access:public
write	writer.h	/^        void write(std::ostream& ss) ;$/;"	p	class:ctb::writer	access:public	signature:(std::ostream& ss)
write	writer.h	/^    void writer<M>::write(std::ostream& ss) $/;"	f	class:ctb::writer	signature:(std::ostream& ss)
write_file	writer.h	/^        void write_file(std::string filename) ; $/;"	p	class:ctb::writer	access:public	signature:(std::string filename)
write_file	writer.h	/^    void writer<M>::write_file(std::string filename)  $/;"	f	class:ctb::writer	signature:(std::string filename)
write_indent	writer.h	/^        void write_indent(std::ostream& ss, const std::string& str, int indent, int nobreak) ;$/;"	p	class:ctb::writer	access:private	signature:(std::ostream& ss, const std::string& str, int indent, int nobreak)
write_indent	writer.h	/^    void writer<M>::write_indent(std::ostream& ss, const std::string& str, int indent, int nobreak)$/;"	f	class:ctb::writer	signature:(std::ostream& ss, const std::string& str, int indent, int nobreak)
write_std	writer.h	/^        void write_std() ; $/;"	p	class:ctb::writer	access:public	signature:()
write_std	writer.h	/^    void writer<M>::write_std()  $/;"	f	class:ctb::writer	signature:()
write_str	writer.h	/^        std::string write_str() ;$/;"	p	class:ctb::writer	access:public	signature:()
write_str	writer.h	/^    std::string writer<M>::write_str()$/;"	f	class:ctb::writer	signature:()
writer	writer.h	/^        template<typename N> writer(const writer<N>& writer);$/;"	p	class:ctb::writer	access:public	signature:(const writer<N>& writer)
writer	writer.h	/^        template<typename N> writer(writer<N>&& writer);$/;"	p	class:ctb::writer	access:public	signature:(writer<N>&& writer)
writer	writer.h	/^        writer();$/;"	p	class:ctb::writer	access:public	signature:()
writer	writer.h	/^        writer(const std::initializer_list<std::string>& init);\/*this one is literal! no parsing here*\/$/;"	p	class:ctb::writer	access:public	signature:(const std::initializer_list<std::string>& init)
writer	writer.h	/^    class writer \/\/will provide methods for outputting the generated code - e.g. autoindent, output to files or stdout$/;"	c	namespace:ctb
writer	writer.h	/^    writer<M>::writer() : data(), last_terminated(true)$/;"	f	class:ctb::writer	signature:()
writer	writer.h	/^    writer<M>::writer(const std::initializer_list<std::string>& init) : data(init), last_terminated(true)\/*the strings are taken literary - id est not formatted*\/$/;"	f	class:ctb::writer	signature:(const std::initializer_list<std::string>& init)
writer	writer.h	/^    writer<M>::writer(const writer<N>& w) : data(w.data), last_terminated(w.last_terminated)$/;"	f	class:ctb::writer	signature:(const writer<N>& w)
writer	writer.h	/^    writer<M>::writer(writer<N>&& w) : data(std::move(w.data)), last_terminated(w.last_terminated)$/;"	f	class:ctb::writer	signature:(writer<N>&& w)
writer_default	model.h	/^  typedef writer<model_empty_cpp> writer_default;$/;"	t	namespace:ctb
writer_default	tags	/^writer_default	model.h	\/^  typedef writer<model_empty_cpp> writer_default;$\/;"	t	namespace:ctb$/;"	t	file:
xml_loader	xmlloader.h	/^    class xml_loader$/;"	c	namespace:ctb
xml_loader::getanystr	sort	/^std::string xml_loader<T,G,IT>::getanystr(tinyxml2::XMLNode * node, std::string name)$/;"	f	class:xml_loader	signature:(tinyxml2::XMLNode * node, std::string name)
